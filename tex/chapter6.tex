\chapter{Properties of RACL}
\label{cha:properties_of_racl}

% Write about the basic ideas behind the proof of preservation and progress

We are now finally ready to state and prove the progress and preservation
properties of RACL. These will then be used in order to prove
quasi determinism. 


\section{Preservation \& Progress}%
\label{sec:preservation_and_progress}

The preservation theorem states that if we have a well typed state that can
step to another state, this will also be well typed.

\begin{theorem}[Preservation]
  \label{thm:preservation}
  Let $S, S'$ be states such that $\vdash S \tsep~\stateok$ and $S \Rrightarrow
  S'$. Then $\vdash S' \tsep \stateok$.
\end{theorem}

The proof of preservation in its full can be found in
Appendix~\ref{cha:proof_of_pnp}. The part concerning preservation of isolation
is probably the most interesting, since properties like well typed heap and
threads are standard. The isolation preservation proof is based on the
fact that, by OCAP reachability, all $\ocap$ threads can only reach $\ocap$
class objects. Combined with global object separation, this means the thread can
never access the global object or create non-$\ocap$ objects through a
$\New{...}$-expression. This implies the thread follows the OCAP model as
described in Section~\ref{sec:the_object_capability_model}. Thus isolated
threads will stay isolated.

\begin{theorem}[Progress]
  \label{thm:progress}
  Let $S$ be a state such that $\vdash S \tsep \stateok$. Then either 
  \begin{enumerate}
    \item $\exists S'$ s.t. $S \Rrightarrow S'$, 
    \item $S = H, \emptyset$ for some heap $H$ s.t. $\noSpawn{(H)}$ or
    \item $S = \Error$.
  \end{enumerate}
\end{theorem}

The progress theorem proof is by contradiction. The full proof can also be found in
Appendix~\ref{cha:proof_of_pnp}.
% Describe:
% Theorem of determinism
% Lemmas leading up to the proof of this

\section{Quasi Determinism}%
\label{sec:quasi_determinism}

Having prooved soundness of the type system, the next thing to proove is quasi
determinism. In order to state this more formally, we need some definitions.

The following is one way to define the concept of a fresh object\slash thread
identifier.
\begin{definition}
  For each state $S = H, P$ there are two related sets of currently used object
  identifiers $\mathcal{O}(S)$ and thread identifiers $\mathcal{D}(S)$.
  Respectively these contain all object and thread identifiers occuring in $H$
  and $P$. 
  %We call an object
  %identifier $o$ (reference identifier $d$) \emph{fresh} if $o \not\in \mathcal{O}(S)$ ($d \not\in
  %\mathcal{D}(S)$).
\end{definition}

\begin{definition}
  We say that an object (thread) identifier $o$ ($d$) is \emph{fresh} at a state $S$ if
  $o \not\in \OIDs(S)$ ($d \not\in \TIDs(S)$).
\end{definition}

Now we define a relation on states and show that this is an equivalence
relation.
\begin{definition} \label{def:eqrel}
  Let $\simeq$ be a binary relation on the set of states $\States$.
  We let $S \simeq S'$ if
  \begin{equation*}
    S = S' = \Error
  \end{equation*}
  or if
  \begin{equation}
    S = H, P \andalso S' = H', P'
  \end{equation}
  and there exists bijections $g: \OIDs \to \OIDs, h: \TIDs \to \TIDs$
  such that
  \begin{equation}
    H' = \pi(H, g) \andalso P' = \rho(P, g, h)
  \end{equation}
  
  The functions $\pi$ and $\rho$ are defined in definition~\ref{def:pirho}.
\end{definition}


\begin{proposition} \label{prop:eqrel}
  $\simeq$ is an equivalence relation.
\end{proposition}

A proof sketch of this can be found in Appendix~\ref{cha:proof_of_qd}.

Similarly we can prove the following. The full proof can also be found in
Appendix~\ref{cha:proof_of_qd}.
\begin{proposition} \label{prop:eqrel_stateok}
  For any $S, S' \in \States$ such that $S \simeq S'$
  \begin{equation}
    \vdash S \tsep \stateok \iff \vdash S' \tsep \stateok
  \end{equation}
\end{proposition}

We make the following observation
\begin{claim}
  A transition between two states can be uniquely identified by
  \begin{itemize}
    \item Start state $S$
    \item Base rule name $R$, e.g., $R = \ENew$ or $R = \ESpawn$. We say base rule
      because in many cases the step involves more than one rule in its
      derivation tree of a complete state step. However the use of these extra
      rules are implied by which rule is used as the "base" of the tree. For
      example, using $\ECall$ to step one thread implies use of $\EFSProp$ to
      advance the state, and using $\ENew$ to advance one thread frame implies
      use of $\EFProp$ and $\EFSProp$ in order to advance the state.
    \item Thread identifier $\iota \in \TIDs$. In the cases where we advance or terminate
      one thread, e.g., $\ENull$ or $\ECall$ this is the thread identifier of
      that thread, as in definition~\ref{def:thread_sets}. In the case where we
      spawn a new thread this is the unique thread identifier as in
      definition~\ref{def:heap_obj}.
    \item A fresh object or thread identifier $\beta$ which could be of value
      \begin{itemize}
        \item Object identifier $o' \in \OIDs$ in the cases where the rule
          references a fresh object identifier, i.e. $\ENew$ and $\ENewCell$.
        \item Thread id $\iota' \in \TIDs$ for the case where a fresh thread id is
          referenced, i.e. $\EWhen$.
        \item $\smiley$ for all other cases.
      \end{itemize}
  \end{itemize}
\end{claim}

Because of this claim we can make the following definition

\begin{definition} \label{def:trans_id}
  We write a \emph{transition identifier} as $R^{\iota, \beta}$. The
  \emph{application} of $R^{\iota, \beta}$ to state $S$ (if possible) is the
  use of a rule specified by $R$, $\iota$ and $\beta$ as described above, to
  step from $S$ to some state $S'$. We write this as
  \begin{equation*}
    S \Rrightarrow^{R^{\iota, \beta}} S'
  \end{equation*}
\end{definition}

\begin{remark}
  Actually the rule name $R$ in the above definition is redundant since this is
  completely decided by the state $S$ and thread identifier $\iota$.
\end{remark}

To simplify notation we make the following definition.

\begin{definition}
  A \emph{transition sequence} $\bar{R}$ is a finite length sequence of
  transition identifiers
  \begin{equation*}
    R_1^{\iota_1, \beta_1}, R_2^{\iota_2, \beta_2}, \dots, R_n^{\iota_n,
    \beta_n}.
  \end{equation*}
  The application of this sequence to a state $S$ is the consecutive application
  of
  \begin{equation*}
    R_i^{\iota_i, \beta_i} \andalso i = 1, \dots, n
  \end{equation*}
  beginning with state $S$. I.e.
  \begin{equation*} 
    S \Rrightarrow^{R_1^{\iota_1, \beta_1}} S_1 \Rrightarrow^{R^{\iota_2,
    \beta_2}} S_2  \: \dots \: S_{n-1} \Rrightarrow^{R_n^{\iota_n, \beta_n}} S_n
  \end{equation*}
  We shorten this to
  \begin{equation*}
    S \Rrightarrow^{\bar{R}} S_n.
  \end{equation*}
\end{definition}

We state the following proposition without proof.
\begin{proposition} \label{prop:uniq_trans}
  Let $H, P \Rrightarrow H', P'$. Then there is a unique transition identifier
  $R^{\alpha, \beta}$ such that $H, P \Rrightarrow^{R^{\alpha, \beta}} H', P'$.
\end{proposition}

We are now ready to state the last main theorem.

\begin{theorem}[Quasi Determinism] \label{thm:qd}
  Let $S, S', T, T'$ be well typed states not equal to $\Error$ such that
  \begin{equation*}
    \begin{gathered}
      S \simeq S' \\
      S \Rrightarrow^{\bar{R}} T \andalso S' \Rrightarrow^{\bar{R'}} T'.
    \end{gathered}
  \end{equation*}
  Furthermore we assume that neither $T$ or $T'$ can make a step.
  Then
  \begin{equation*}
    T \simeq T'.
  \end{equation*}
\end{theorem}

The proof of theorem~\ref{thm:qd} is based on induction on the length of the two
transition sequences. It can be seen as incrementally transforming $\bar{R'}$ to
$\bar{R}$ by moving transition specifiers to positions specified by $\bar{R}$.
Each intermediate sequence is shown to halt in the same state.

Finally, this corollary follows from theorem~\ref{thm:qd} and
proposition~\ref{prop:uniq_trans}:
\begin{corollary}
  Let $S, S', T, T'$ be well typed states not equal to $\Error$ such that
  \begin{equation*}
    \begin{gathered}
      S \simeq S' \\
      S \Rrightarrow^* T \andalso S' \Rrightarrow^* T'.
    \end{gathered}
  \end{equation*}
  Furthermore we assume that neither $T$ or $T'$ can make a step.
  Then
  \begin{equation*}
    T \simeq T'.
  \end{equation*}
\end{corollary}

