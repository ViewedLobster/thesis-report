\chapter{Core Language}%
\label{cha:core_language}

In this chapter a basic core language is introduced. It will build a lot upon
the core languages of LaCasa and LVish and combine the two. In the end we will
have an object oriented language incorporating many of the features of LVish with
a type system enforcing OCAP properties, much like the system of LaCasa.

\section{Syntax}
\label{sec:syntax}

The language which we shall call Reactive Async Core Language (RACL) has a big
similarity with the core language from LaCasa. Many expressions are the same
except for a few removals and additions. The language grammar is defined in
Figure~\ref{fig:racl_grammar}. It is a simple object oriented language which is
parameterized on the lattice \LatVals{}.

\begin{figure}
  \centering
  $\begin{array}{lll@{\hspace{4mm}}l}
    p &::= &\overline{cd}~\overline{vd}~t  & \mbox{Program} \\
    cd &::= &\texttt{class}~C~\texttt{extends}~D~\{\overline{fd}~\overline{md}\}
    & \mbox{Class} \\
    vd,fd &::= &\texttt{var}~f~:~\tau & \mbox{Variable/Field} \\
    md &::= &\texttt{def}~m(x: \sigma):~\tau = t & \mbox{Method}\\
    &&&\\
    \sigma,\tau & ::= & & \mbox{Types} \\
    & & C, D & \mbox{Class types} \\ 
    &| & \CellType & \mbox{Cell type} \\
    &| & \NullType & \mbox{Null type} \\
    &| & \LatType & \mbox{Lattice value type} \\
    &&&\\
    t &::=& & \mbox{Terms} \\
    & & x & \mbox{Variable} \\
    &|& \texttt{let}~x = e~\texttt{in}~t &\mbox{Let binding} \\
    &&&\\
    e &::=& & \mbox{Expression} \\
    & & l & \mbox{Lattice value} \\
    &|& \texttt{null} & \mbox{Null reference} \\
    &|& x &\mbox{Variable} \\
    &|& x.f &\mbox{Field selection} \\
    &|& x.f = y & \mbox{Field assignment} \\
    &|& \texttt{new}~C & \mbox{Class instance creation} \\
    &|& \texttt{new}~\texttt{Cell} & \mbox{Cell instance creation} \\
    &|& x.m(y) & \mbox{Method invocation} \\
    &|& x~\texttt{put}~y & \mbox{Cell value update} \\
    &|& \texttt{when}~x~\texttt{pass}~y~\texttt{then}~(\overline{cap}, z
    \Rightarrow t) & \mbox{Dependency creation} \\
    &&&\\
    cap & ::= & x = y & \mbox{Variable capture} \\
  \end{array}$
  \caption{Grammar of RACL}
  \label{fig:racl_grammar}
\end{figure}

We can see a program $p$ consists of a sequence of class definitions
$\overline{cd}$, a sequence of variable declarations $\overline{vd}$ and a term
$t$. A class definition $cd$ as would be expected consists of a name specifier
$C$, inheritance specifier $D$, field declarations $\overline{fd}$ and method
definitions $\overline{md}$. Variable and field declarations both have the same
form consisting of a name specifier $f$ and a type $\tau$. Method definitions
are also standard, with one thing to note that all methods takes exactly one
input. More complicated inputs can be constructed using a container class.

The type specifiers $\sigma$ and $\tau$ can take on the values as specified.
Note that we have the special \CellType{} and \LatType{} types which are meant
to represent the cells of reactive async and values from the used lattice. Types
will be discussed more in Section~\ref{sec:type_system}.

As with LaCasa the terms of RACL are written in ANF (i.e.\ every expression is
named). Most of the expressions should be self explanatory, but note for example
that we have a separate instance creation expression for cells, an expression
for updating the value of a cell aswell as an expression for creating
dependencies between cells. The semantics of these will be explained next.

\section{Semantics}%
\label{sec:semantics}

% TODO describe the rules a bit
% TODO state that program execution starts from starting state

In this section the semantics of \RACL{} will be introduced. First a brief
overview is made and then a few of the more interesting or non-standard
execution rules will be explained.

In short the next few definitions says that the state of the execution of a
\RACL{} program consists of a \emph{heap} and a \emph{thread set}. The heap is
represented by a partial map from object identifiers $\OIDs$ to objects
$\Objects$. The thread set is a set of threads each of which consists of call
stacks. Each call stack consists of frames, each of which holds a local variable
environment and a term to be executed. Steps between states can be made accoring
to rules on either frame, frame stack or thread set level. All steps taken on
lower levels are propagated to thread set level using auxilliary rules. After
the following definitions we describe the execution rules in more detail.

\subsection{Semantical Definitions}%
\label{sub:semantical_definitions}

\begin{definition}[Sets] We define the following sets.
  \begin{itemize}
    \item We let $\VarNames$ be the set of all allowed variable names.
    \item We let $\FieldNames$ be the set of all allowed field names.
    \item We let $\LatVals$ be the set of all lattice elements.
    \item We let $\OIDs$ be the set of all object identifiers.
    \item We let $\TIDs$ be the set of all thread identifiers.
    \item We let $\NullVal$ be the special null value.
    \item We let $\Values$ be the set of all possible runtime values
      \begin{equation*}
        \Values = \LatVals \cup \OIDs \cup \left\{ \NullVal \right\}.
      \end{equation*}
    \item We let $\ocapstats$ be the set of OCAP statuses
      \begin{equation*}
        \ocapstats = \left\{ \ocap, \nocap \right\}.
      \end{equation*}
  \end{itemize}
\end{definition}

\begin{definition}[Heap Objects]\label{def:heap_obj}
  We let $\Objects$ be the set of all \emph{heap objects}, i.e. objects of the
  form
  \begin{equation*}
    \Obj{C, FM} \text{ or } \Cell{DEP, l}.
  \end{equation*}
  In $\Obj{C, FM}$, $FM$ is a partial map
  \begin{equation*}
    FM: \FieldNames \rightharpoonup \Values.
  \end{equation*}
  In $\Cell{DEP, l}$, $l \in \LatVals$ and $DEP$ is a set of elements of the
  form
  \begin{equation*}
    (l' , (L_{\text{env}}, z \Rightarrow t))^\iota
  \end{equation*}
  where $l' \in \LatVals$, $L_{\text{env}}$ is a local environment, $z \in
  \VarNames$, $t$ is a term and $\iota \in \TIDs$ is a unique thread identifier. The
  uniqueness of $\iota$ is global to the state of a program.
\end{definition}

\begin{definition}
  A \emph{heap} $H$ is a partial map
  \begin{equation*}
    H: \OIDs \rightharpoonup \Objects.
  \end{equation*}
\end{definition}

\begin{definition}
  A \emph{local environment} $L$ is a partial map
  \begin{equation*}
    L: \VarNames \rightharpoonup \Values.
  \end{equation*}
\end{definition}

\begin{definition}\label{def:thread_sets}
  A \emph{frame} $F$ is an object of the form
  \begin{equation*}
    \sframe{L, t}
  \end{equation*}
  where $L$ is a local environment, $t$ is a term and $s \in \VarNames$ is a
  return tag.

  A \emph{frame stack} $FS$ is a finitely large stack of frames. We can write
  all of these recursively as either the empty stack $FS = \varepsilon$, or as
  $FS = F \circ GS$ where $GS$ is also a frame stack.

  A \emph{thread set} $P$ is a finite set 
  \begin{equation*}
    P = \left\{ FS_i|_{a_i}^{\iota_i} \right\}_{i = 1}^{n}
  \end{equation*}
  of frame stacks $FS_i$ tagged with a unique thread id $\iota_i \in \TIDs$ and an
  OCAP status $a_i \in \ocapstats$. Note that $P$ can be the empty set.
\end{definition}

\begin{definition}{(States)}
  We define a \emph{state} to be either the error state $\Error$ or a pair $H,
  P$ where $H$ is a heap and $P$ is a thread set.
\end{definition}

\begin{definition}
  The set of all valid types $\ValidTypes$ for a given program $p$ consists of
  $\AnyRefType$, $\NullType$, $\CellType$, $\LatType$ and all defined
  class types in $p$, $\ClassTypes$. I.e.
  \begin{equation*}
    \ValidTypes = \ClassTypes \cup \left\{ \AnyRefType, \NullType, \CellType,
    \LatType \right\}
  \end{equation*}
\end{definition}

\begin{definition}
  The function $\default: \ValidTypes \to \Values$ is defined as follows
  \begin{equation*}
    \default(\tau) =
    \begin{cases}
      \bot_{\LatVals} & \text{ if } \tau = \LatType \\
      \NullVal        & \text{ otherwise } 
    \end{cases}
  \end{equation*}
\end{definition}

\begin{definition}
  Execution of a program starts from state $S_0 = H_0, P_0$ where $H_0$ and
  $P_0$ are defined as follows. 
  \begin{equation*}
    H_0
  \end{equation*}
\end{definition}

\subsection{Reduction Rules}%
\label{sub:reduction_rules}

An execution step from state $S$ to $S'$ in RACL is expressed using the relation
\begin{equation*}
  S \Rrightarrow S'.
\end{equation*}
RACL reduction rules are expressed at three different levels:
Thread set, frame stack and frame level. 
Therefore we will also see the relations 
\begin{equation*}
  H, FS \;\FSRedTo\; H', FS' \quad \text{ and } \quad H, F\; \FRedTo\; H', F'
\end{equation*}
This is to allow expression of e.g. single frame execution,
thread creation and method calls as will be explained below. 
A reduction on frame or frame stack level are propagated up to thread set level
with the rules \EFProp{} and \EFSProp{} which are defined in
figures~\ref{fig:fs_red_rules} and~\ref{fig:threads_red_rules}.

In Figure~\ref{fig:frame_red_rules}, reduction rules for single frames are
defined. These are rules that advance the state of a single frame $F$ and
possibly changes the heap $H$. We have very simple ones like the rule {\sc
E-LVal}, which assigns the specified lattice value to a local variable and the
rule {\sc E-Var} which assigns the value of one local variable to another one.
The rules \ESelect{} and \EAssign{} respectively fetches and sets the value of a
field $f$ of an object on the heap. Rules \ENew{} and \ENewCell{} creates a new
object on the heap of either class or cell type and assigns the corresponding
new object identifier to a local variable. The rule \EPut{} updates the value of
a cell object on the heap through a join operation.  Finally the rule \EWhen{}
is responsible for adding a new dependency with callback. Looking at this rule
more closely we see that it captures the variables specified by $\overline{cap}$
and creates a local environment $L_{\text{env}}$. This is then stored, together
with the closure $w \Rightarrow t'$, a threshold value $l'$ and a fresh thread
identifier $\iota$, in the new dependency set $DEP'$. Note that all rules in
Figure~\ref{fig:frame_red_rules} assigns something to the variable $x$.

In Figure~\ref{fig:error_red_rules}, rules that lead to error are defined. These
are all what would be called null-pointer exceptions in a language like Java.
That is, that we try to access an object through the $\NullVal$ identifier.
Errors are then propagated to frame stack and thread set level using rules
\EErrorFS{} and \EErrorP{} from figures~\ref{fig:fs_red_rules} and
\ref{fig:threads_red_rules}.

In Figure~\ref{fig:fs_red_rules}, rules for frame stack reductions are defined.
Here we find the aforementioned \EFProp{} and \EErrorFS{} together with rules
for method calls and returns. \ECall{} handles method calls by creating a new
frame with the corresponding term and local environment. Note that the new local
environment differs depending on the OCAP status of the working thread. If the
thread is tagged with $a = \nocap$ the new frame also has access to the global
environment, while if $a = \ocap$ it will not. Note also that the new frame
stack is tagged with the variable name $x$, the variable being assigned the
method result in rule \ERet{}. \ERet{} corresponds to method return and utilizes
the aforementioned variable name tag. Note that none of these rules changes the
thread identifier or OCAP status of a thread.

Finally, in Figure~\ref{fig:threads_red_rules}, the rules for thread set
reductions are defined. Here we find \EFSProp{} and \EErrorP{} which were
mentioned above. Furthermore we have rule \ESpawn{}, which spawns a new callback
thread for the threshold value $l$ in the cell specified by $o$. \ETerm{} is a
rule to remove any thread stack finished with its execution.

\begin{figure}[h]
  \scax{E-Null}
  {H, \sFrame{L}{\Let{x}{\NullVal}{t}} \; \FRedTo \; H, \sFrame{L[x \mapsto
  \NullVal]}{t}}

  \RuleSpace{}

  \scax{E-LVal}
  {H, \sFrame{L}{\Let{x}{l}{t}} \; \FRedTo \; H, \sFrame{L[x \mapsto
  l]}{t}}

  \RuleSpace{}

  \scax{E-Var}
  {H, \sFrame{L}{\Let{x}{y}{t}} \; \FRedTo \; H, \sFrame{L[x \mapsto
  L(y)]}{t}}

  \RuleSpace{}

  \scrule{E-Select}
  {L(y) = o \andalso H(o) = \Obj{C, FM} \andalso f \in \dom(FM)}
  {H, \sFrame{L}{\Let{x}{ \FSel{y}{f} }{t}} \; \FRedTo  \\ 
  H, \sFrame{L[x \mapsto FM(f)]}{t}}

  \RuleSpace{}

  \scrule{E-Assign}
  {L(y) = o \andalso H(o) = \Obj{C, FM} \andalso f \in \dom(FM) \\
  FM' = FM[f \mapsto L(z)] \andalso H' = H[o \mapsto \Obj{C, FM'}]}
  {H, \sFrame{L}{\Let{x}{\FAss{y}{f}{z}}{t}} \; \FRedTo \\
   H', \sFrame{L[x \mapsto L(z)]}{t}}

  \RuleSpace{}

  \scrule{E-New}
  {o\text{ fresh object identifier } \\
  FM = [f \mapsto \default(\sigma): (\VarDecl{f}{\sigma}) \in \fdecls(C)] \\
  H' = H[o \mapsto \Obj{C, FM}]}
  {H, \sFrame{L}{ \Let{x}{\New{C}}{t} } \; \FRedTo \\
  H', \sFrame{L[x \mapsto o]}{t}}
  
  \RuleSpace{}

  \scrule{E-NewCell}
  {o\text{ fresh object identifier } \andalso
  H' = H[o \mapsto \Cell{\emptyset, \bot_{\LatVals{}}}]}
  {H, \sFrame{L}{ \Let{x}{\NewCell}{t} } \; \FRedTo \\
  H', \sFrame{L[x \mapsto o]}{t}}

  \RuleSpace{}
  
  \scrule{E-Put}
  {L(y) = o \andalso H(o) = \Cell{DEP, l} \\
  L(z) = l' \andalso c' = \Cell{DEP, l \sqcup l'} \\
  H' = H[o \mapsto c']}
  {H, \sFrame{L}{\Let{x}{\Put{y}{z}}{t}} \; \FRedTo \\
  H', \sFrame{L[x \mapsto L(y)]}{t}}

  \RuleSpace{}

  \scrule{E-When}
  {L(y) = o \andalso H(o) = \Cell{DEP, l} \andalso L(z) = l' \\
  L_{\text{env}} = [u \mapsto L(u') : (\Capt{u}{u'}) \in \overline{cap}]
  \andalso cb = (L_{\text{env}}, w \Rightarrow t') \\
  \iota\text{ fresh thread identifier } \andalso DEP' = DEP \cup (l', cb)^\iota \\
  H' = H[o \mapsto \Cell{DEP', l}] }
  { H, \sFrame{L}{ \Let{x}{ \When{y}{z}{ (\overline{cap}, w \Rightarrow t') }}{t} } \\ \FRedTo \;
  H', \sFrame{L[x \mapsto L(y)]}{t} }
  \caption{\RACL{} single frame reduction rules.}
  \label{fig:frame_red_rules}
\end{figure}


\begin{figure}
  \scrule{E-NullSelect}
  {L(y) = \NullVal}
  {H, \sFrame{L, \Let{x}{\FSel{y}{f}}{t} } \; \FRedTo \; \Error}

  \RuleSpace{}

  \scrule{E-NullAssign}
  {L(y) = \NullVal}
  {H, \sFrame{L, \Let{x}{\FAss{y}{f}{z}}{t} } \; \FRedTo \; \Error}

  \RuleSpace{}

  \scrule{E-NullCall}
  {L(y) = \NullVal}
  {H, \sFrame{L, \Let{x}{\Call{y}{m}{z}}{t} } \; \FRedTo \; \Error}

  \RuleSpace{}

  \scrule{E-NullPut}
  {L(y) = \NullVal}
  {H, \sFrame{L, \Let{x}{\Put{y}{z}}{t} } \; \FRedTo \; \Error}

  \RuleSpace{}

  \scrule{E-NullWhen}
  {L(y) = \NullVal}
  {H, \sFrame{L}{\Let{x}{  \When{y}{z}{ (\overline{cap}, w \Rightarrow t')}}{t}
  }  \\ \FRedTo \; \Error}
  \caption{\RACL{} error spawning rules.}
  \label{fig:error_red_rules}
\end{figure}

\begin{figure}
  \scrule{E-Call}
  {
    L(y) = o \andalso H(o) = \Obj{C, FM} \\
    \mbody(m, C) = w \to t' \\
    L_{\text{base}} =
    \begin{cases}
      \emptyset & \text{if } a = \ocap \\
      L_0 & \text{if } a = \nocap
    \end{cases} \\
    L' = L_{\text{base}}[\This \mapsto L(y), w \mapsto L(z)] 
  }
  {H, \sFrame{L}{ \Let{x}{ \Call{y}{m}{z} }{t} } \circ FS |_a^\iota \; \FSRedTo \\
  H, \Frame{L'}{t'}{x} \circ \sFrame{L}{t} \circ FS |_a^\iota}

  \RuleSpace{}

  \scax{E-Ret}
  {H, \Frame{L'}{x}{y} \circ \sframe{L, t} \circ FS |_a^\iota \; \FSRedTo \\
  H, \sFrame{L[y \mapsto L'(x)]}{t} \circ FS |_a^\iota }

  \RuleSpace{}

  \scrule{E-FProp}
  {H, F \; \FRedTo \; H', F'}
  {H, F \circ FS |_a^\iota \; \FSRedTo \; H', F' \circ FS |_a^\iota }

  \RuleSpace{}
  
  \scrule{E-ErrorFS}
  {H, F \; \FRedTo \; \Error }
  {H, F \circ FS |_a^\iota \; \FSRedTo \; \Error}

  \caption{\RACL{} frame stack reduction rules.}
  \label{fig:fs_red_rules}
\end{figure}

\begin{figure}
  \scrule{E-Spawn}
  {
    o \in \dom(H) \andalso H(o) = \Cell{DEP, l} \\ 
    l' \sqsubseteq l \andalso (l', cb)^\iota \in DEP \andalso cb = (L_{\text{env}}, z
    \Rightarrow t) \\
    L = L_{\text{env}}[z \mapsto l'] \\
    H' = H[o \mapsto \Cell{DEP - (l', cb)^\iota, l}]
  }
  {
    H,P \Rrightarrow H', P \cup \left\{ \Frame{L}{t}{-} \circ \varepsilon
    |_{\ocap}^{\iota} \right\}
  }

  \RuleSpace{}

  \scrule{E-Term}
  {P = P' \cup_D \left\{ \sFrame{L}{x} \circ \varepsilon |_a^\iota \right\} }
  {H,P \Rrightarrow H, P'}

  \RuleSpace{}

  \scrule{E-FSProp}
  {H, FS \twoheadrightarrow H', FS'}
  {H, P \cup_D \left\{ FS \right\} \Rrightarrow H', P \cup \left\{ FS' \right\} }

  \RuleSpace{}

  \scrule{E-ErrorP}
  {H, FS \twoheadrightarrow \Error}
  {H, P \cup_D \left\{ FS \right\} \Rrightarrow \Error }
  \caption{\RACL{} thread set reduction rules.}
  \label{fig:threads_red_rules}
\end{figure}


\section{Type System}
\label{sec:type_system}

\begin{figure}
  \begin{multicols}{2}

    \scax{ST-Top}
    {\tau \stof \RaclTop}

    \RuleSpace

    \scax{ST-Bot}
    {\RaclBot \stof \tau}

    \RuleSpace

    \scax{ST-Cell-AnyRef}
    {\CellType \stof \AnyRefType}

    \RuleSpace

    \scax{ST-C-AnyRef}
    {C \stof \AnyRefType}

    \RuleSpace

    \scax{ST-Null-Cell}
    {\NullType \stof \CellType}
    
    \RuleSpace

    \scax{ST-Null-C}
    {\NullType \stof C}
  \end{multicols}

  \RuleSpace

  \scrule{ST-C-D}
  {p \vdash \ClassDef{C}{D}{...}{...}}
  {C \stof D}

  \caption{Subtyping relation of RACL}
  \label{fig:def_stof}
\end{figure}

The subtyping relation of RACL is defined in Figure~\ref{fig:def_stof}.  The
types and type lattice of RACL is summarized in Figure~\ref{fig:racl_typelat}.
Except for the standard types we see that the \CellType{} type is a subtype of
\AnyRefType{} like the class types. Intuitively this originates from that cell
values are stored on the heap. We also have a separate lattice value type
\LatType{}.

\begin{figure}[]
  \centering
  \begin{tikzpicture} 
    \node (top) at (1,3) {$\RaclTop$};
    \node (anyref) at (2,2) {\AnyRefType};
    \node (cell) at (1,1) {\CellType};
    \node (classes) at (3,1) {$C,D$};
    \node (null) at (2,0) {\NullType};
    \node (lat) at (-1, 1) {\LatType};
    \node (bot) at (1, -1) {$\RaclBot$};
    \draw (top) -- (lat) -- (bot) -- (null) -- (classes) -- (anyref) -- (top);
    \draw (anyref) -- (cell) -- (null);
  \end{tikzpicture}
  \caption{Type lattice of RACL}
  \label{fig:racl_typelat}
\end{figure}

\subsection{Terms \& Expressions}%
\label{sub:terms_and_expressions}

The basic building blocks of our type system are the typing of expressions and
terms. Our type relation is written
\begin{equation}
  \TypeRel{\Gamma}{a}{t}{\tau} \quad \text{ or } \quad
  \TypeRel{\Gamma}{a}{e}{\tau}. \notag
\end{equation}
Apart from the usual parts of typing environment $\Gamma$, term $t$ or
expression $e$ and type $\tau$, we note that it includes a designator $a$ which
can take on the values \nocap{} and \ocap{}. The latter indicates that the term
or expression is typed under OCAP constraints. This is equivalent to the OCAP
typing of \LaCasa{}~\parencite{conf/oopsla/HallerL16}. 

All typing rules for terms and expressions can be found in
Figure~\ref{fig:expr_typing}. Most of the type system rules are standard. For
example, rule {\sc T-Let} types a let-term if the subexpression $e$ is typeable
as $\tau$ under $\Gamma; a$, and the subterm $t$ is typeable under the extended
environment $\Gamma, x: \tau$ and $a$. Rule {\sc T-Var} types a variable under
$\Gamma$ provided $x \in \dom(\Gamma)$. {\sc T-New} types $\New{C}$ under effect
$a = \ocap$ only if the class $C$ is typeable as $\ocap$. The rules for typing a
class as $\ocap$ is defined in Figure~\ref{fig:ocap_typing}. Typing rule {\sc
T-Call} states that a method call $\Call{x}{m}{y}$, is only typeable if the type
of $y$ is a subtype of the method parameter type $\sigma$. {\sc T-Put} types the
expression $\Put{x}{y}$ if $x$ is typeable as \CellType{} and $y$ is of the lattice
type \LatType.

As a final example, the rule {\sc T-When} describes typing of the dependency
creation expression. It says that in order to register a callback for lattice
value $y$ in cell $x$, first $x$ and $y$ must be typeable as $\CellType$ and
$\LatType$ respectively. Furthermore all captured variables in $\overline{cap}$
must be typeable as $\CellType$.  Finally, the term $t$ from callback closure $z
\Rightarrow t$ must be typeable in an environment consisting of the captured
variables and $z: \LatType$.

\subsection{Well Formed Programs}%
\label{sub:well_formed_programs}

In order to decide
The rules for a well formed programs can be found in Figure~\ref{fig:wf_typing}.
{\sc WF-Prog} says that 

\begin{figure}[h!]
  \centering
  %\begin{multicols}{2}
    \scrule{T-Let}
    {\TypeRel{\Gamma}{a}{e}{\tau} \andalso \TypeRel{\Gamma,x:
    \tau}{a}{t}{\sigma}}
    {\TypeRel{\Gamma}{a}{ \Let{x}{e}{t} }{\sigma}}

    \vspace{0.5em}

    \scax{T-Null}{\TypeRel{\Gamma}{a}{\NullVal}{\NullType}}

    \vspace{0.5em}

    \scax{T-LVal}{\TypeRel{\Gamma}{a}{l}{\LatType}}
    
    \vspace{0.5em}

    \scrule{T-Var}{x \in \dom(\Gamma)}{\TypeRel{\Gamma}{a}{x}{\Gamma(x)}}

    \vspace{0.5em}

    \scrule{T-Select}
    {\TypeRel{\Gamma}{a}{x}{C} \andalso \ftype(f, C) = \tau }
    {\TypeRel{\Gamma}{a}{\FSel{x}{f}}{\tau}}
    
    \vspace{0.5em}

    \scrule{T-Assign}
    {\TypeRel{\Gamma}{a}{x}{C} \andalso \ftype(f, C) = \tau \\
    \TypeRel{\Gamma}{a}{y}{\tau'} \andalso \tau' \stof \tau }
    {\TypeRel{\Gamma}{a}{\FAss{x}{f}{y}}{\tau}}

    \vspace{0.5em}

    \scrule{T-New}
    {a = \ocap \Longrightarrow \ocap(C)}
    {\TypeRel{\Gamma}{a}{\New{C}}{C}}

    \vspace{0.5em}

    \scax{T-NewCell}{\TypeRel{\Gamma}{a}{\NewCell}{\CellType}}
    
    \vspace{0.5em}

    \scrule{T-Call}
    {\TypeRel{\Gamma}{a}{x}{C} \andalso \mtype(C,m) = \sigma \to \tau \\
    \TypeRel{\Gamma}{a}{y}{\sigma'} \andalso \sigma' \stof \sigma }
    {\TypeRel{\Gamma}{a}{\Call{x}{m}{y}}{\tau}}
    
    \vspace{0.5em}

    \scrule{T-Put}
    {\TypeRel{\Gamma}{a}{x}{\CellType} \andalso \TypeRel{\Gamma}{a}{y}{\LatType}}
    {\TypeRel{\Gamma}{a}{\Put{x}{y}}{\CellType}}
    
    \vspace{0.5em}

    \scrule{T-When}
    {\TypeRel{\Gamma}{a}{x}{\CellType} \andalso \TypeRel{\Gamma}{a}{y}{\LatType} \\
    \forall \Capt{u}{u'} \in \overline{cap}. \; \TypeRel{\Gamma}{a}{u'}{\CellType}\\
    \Gamma_{\text{cells}} = [u \mapsto \CellType : \Capt{u}{u'} \in \overline{cap}]\\
    \TypeRel{\Gamma_{\text{cells}}, z : \LatType}{\ocap}{t}{\sigma}}
    { \TypeRel{\Gamma}{a}{\When{x}{y}{ \CB{\overline{cap}}{z}{t}}}{\CellType} }

  %\end{multicols}
  \caption{\RACL{} typing rules for expressions and terms.}
  \label{fig:expr_typing}
\end{figure}

\begin{figure}[h]
  \scrule{WF-Prog}
  {p \vdash \overline{cd} \andalso p \vdash \Gamma_0 \andalso
  \TypeRel{\Gamma_0}{\nocap}{t}{\tau}}
  {p \vdash \overline{cd} \: \overline{vd} \: t}

  \RuleSpace{}

  \scrule{WF-Class}
  {C \vdash \overline{md} \\ D = \AnyRefType{} \lor
  p \vdash \ClassDef{D}{...}{...}{...} \\
  \forall (\MethodDef{m}{...}{...}{...}{...}) \in \overline{md} . \: \override(m,
  C, D) \\
  \forall (\VarDecl{f}{\tau}) \in \overline{vd} . \: f \notin \fields(D) }
  {p \vdash \ClassDef{C}{D}{\overline{vd}}{\overline{md}}}

  \RuleSpace{}

  \scrule{WF-Override}
  {\mtype(m, D)\text{ not def. } \lor \mtype(m, C) = \mtype(m, D)}
  {\override(m, C, D)}
  
  \RuleSpace{}

  \scrule{WF-Method}
  { \TypeRel{\Gamma_0, \This:C, x : \sigma}{\nocap}{t}{\tau'} \\
  \tau' \stof \tau}
  {C \vdash \MethodDef{m}{x}{\sigma}{\tau}{t}}
  \caption{\RACL{} rules for well formedness of programs.}
  \label{fig:wf_typing}
\end{figure}


\begin{figure}
  \scax{OCAP-AnyRef}
  {\ocap{(\AnyRefType{})}}

  \RuleSpace{}

  \scax{OCAP-Cell}
  {\ocap(\CellType)}

  \RuleSpace{}

  \scrule{OCAP-Class}
  {\ocap{(D)} \andalso C \vdash_{\ocap} \overline{md} \\
  \forall (\VarDecl{f}{\sigma}) \in \overline{vd}. \: ocap(\sigma)}
  {\ocap{(C)}}

  \RuleSpace{}

  \scrule{OCAP-Method}
  {\TypeRel{\This : C, x : \sigma}{\ocap}{t}{\tau'} \\
  \tau' \stof \tau}
  {C \vdash_{\ocap} \MethodDef{m}{x}{\sigma}{\tau}{t}}
  \caption{\RACL{} OCAP rules.}
  \label{fig:ocap_typing}
\end{figure}


\section{Properties}
\label{sec:properties}

\begin{definition}
  The partial function $\typeOf$ is defined as follows:
  \begin{equation}
    \typeOf{(k, H)} =
    \begin{cases}
      \LatType, &\text{ if }k \in \LatVals \\
      \NullType, &\text{ if }k = \NullVal \\
      \CellType, &\text{ if }k \in \dom{(H)}\text{ and } H(k) = \Cell{...} \\
      C, &\text{ if }k \in \dom{(H)}\text{ and } H(k) = \Obj{C, ...} \\
    \end{cases}
  \end{equation}
  The typing environment $\Gamma_{\CellType}(L)$ is defined as follows:
  \begin{equation}
    \Gamma_{\CellType}(L) = \left[(x: \CellType) : x \in \dom(L)\right]
  \end{equation}
\end{definition}


\begin{definition}[Well Typed Heap]
  A heap $H$ is well typed, written $\vdash{H}$, if
  $\forall o \in \dom{(H)}$:

  If $H(o) = \Obj{C, FM}$ then
  \begin{equation} \label{eq:defwth1}
    \begin{aligned}
      \forall f &\in \fields{(C)}. \\ 
      &f \in \dom{(FM)} \: \land \\ 
      &\typeOf{(FM(f), H)} \stof \ftype{(f, C)}
    \end{aligned}
  \end{equation}
  and if $H(o) = \Cell{DEP, l}$ then
  \begin{equation} \label{eq:defwth2}
    \begin{aligned}
      \forall (l'&, (L_{\text{env}}, z \Rightarrow t))^\iota \in DEP. \\
      &\forall (x \mapsto k) \in L_{\text{env}}.\: \typeOf{(k, H)} \stof
      \CellType \: \land \\
      &\TypeRel{\Gamma_{\CellType{}}(L_{\text{env}}), z:
      \LatType}{\ocap}{t}{\gamma} 
    \end{aligned}
  \end{equation}
\end{definition}


\begin{definition}[Class Object Separation]
  For any heap $H$ and heap references $o, o'$ we have class object separation,
  $\csep{(H, o, o')}$ iff
  \begin{align}
    \label{eq:csep_def}
    \forall q, q' &\in \dom{(H)}. \notag\\
    & \reach{(H, o, q)} \: \land \: \reach{(H, o', q')} \implies \notag\\ 
    &q \neq q' \: \lor \typeOf{(q, H)} = \CellType
  \end{align}
\end{definition}

\begin{definition}[Accessible Roots]
  For a heap $H$ and a frame stack $FS$ we define $\accRoots{(FS, H)}$ as

  \begin{equation}
    \accRoots{(FS, H)} = \left\{ o \in \dom{(H)}: \accRoot{(o, FS)} \right\}
  \end{equation}
\end{definition}

\begin{definition}[OCAP Reachability]
  For a heap $H$ and frame stack $FS$ we have $\ocrloc{(FS,H)}$ iff
  \begin{align}
    \label{eq:ocr_def}
    \forall o \in \: &\accRoots(FS,H), o' \in \dom(H). \notag\\
    &\reach{(H, o, o')} \implies \ocap{(\typeOf{(o', H)})}
  \end{align}
\end{definition}

\begin{definition}[No Spawn]
  For any heap $H$ we have $\noSpawn(H)$ if and only if
  \begin{equation}
    \begin{aligned}
      \forall o &\in \dom(H). \\
        & H(o) = \Cell{DEP, l} \implies 
        \forall (l', cb)^\iota \in DEP. \: \lnot (l' \sqsubseteq l).
    \end{aligned}
  \end{equation}
\end{definition}

\begin{definition}[Unique Main Thread]
  For a thread $FS|_a^\iota$ let
  \begin{equation*}
    \chi_{\nocap}(a) =
    \begin{cases}
      1 & \text{ if } a = \nocap \\
      0 & \text{ o.w. }
    \end{cases}
  \end{equation*}
  For a thread set $P$ let
  \begin{equation*}
    \chi(P) = \sum_{FS|_a^\iota \in P} \chi_{\nocap}(a).
  \end{equation*}
  This is the number of non OCAP protected threads in $P$. Finally we define
  \begin{equation*}
    \uniqMain(P) \iff \chi(P) \leq 1
  \end{equation*}
\end{definition}

\begin{definition}[Well Typed States]
  A state $S$ is a value of either $\Error$ or a pair $H, P$ where $H$ is a heap
  and $P$ is a set of threads. For a state $S$ we say that it is well typed,
  written
  \begin{equation}
    \vdash S \tsep \stateok
  \end{equation}
  if $S = \Error$ or $S = H, P$ and
  \begin{equation*}
    \begin{gathered}
      \vdash H \andalso H \vdash P \andalso H \vdash P \tsep \ocr \\
      \isolation{(H, P)} \andalso H \vdash P \tsep \gsep \andalso \uniqMain(P)
    \end{gathered}
  \end{equation*}
  
\end{definition}

\begin{figure}
  \scrule{WF-EnvVar}
  {\typeOf{(L(x), H) \stof \Gamma{(x)}}}
  { H \vdash \Gamma; L; x }

  \RuleSpace{}

  \scrule{WF-Env}
  {\dom{(\Gamma)} \subseteq \dom{(L)} \\
    \forall x \in \dom{(\Gamma)}. \: H \vdash \Gamma; L; x 
  }
  { H \vdash \Gamma; L }

  \caption{Rules for classifying local environments $L$ as well typed.}
  \label{fig:local_typing}
\end{figure}

\begin{figure}
  \scax{T-FSEmpty1}
  {H; a \vdash \varepsilon}

  \RuleSpace{}

  \scax{T-FSEmpty2}
  {H; a \vdash^{x : \sigma} \varepsilon}

  \RuleSpace{}

  \scrule{T-FS1}
  { F = \Frame{L}{t}{x} \andalso H \vdash \Gamma; L \\
  \TypeRel{\Gamma}{a}{t}{\sigma'} \andalso \sigma' \stof \sigma \andalso H; a \vdash^{x: \sigma} FS }
  { H; a \vdash F \circ FS }
  
  \RuleSpace{}

  \scrule{T-FS2}
  { F = \Frame{L}{t}{y} \andalso H \vdash \Gamma; L \\
  \TypeRel{\Gamma, x: \tau}{a}{t}{\sigma'} \andalso \sigma' \stof \sigma 
  \andalso H; a \vdash^{y: \sigma} FS }
  { H; a \vdash^{x: \tau} F \circ FS }

  \caption{Rules for typing frame stacks under some heap $H$ and effect $a$.}
  \label{fig:fs_typing}
\end{figure}

\begin{figure}
  \scax{T-Empty}
  {H \vdash \emptyset}

  \RuleSpace{}

  \scrule{T-Procs}
  { H; a \vdash FS \andalso H \vdash P }
  { H \vdash P \cup \left\{FS |_a^\iota \right\} }

  \caption{Rules for typing thread sets and the special value \Error{} under some heap $H$.}
  \label{fig:ts_typing}
\end{figure}

\begin{figure}
  \scrule{ISO-FS}
  { 
    \forall o \in \accRoots(FS), o' \in \accRoots(GS) . \: \csep{(H, o, o')}
  }
  {
    \isolated{(H, FS, GS)}
  }
  
  \RuleSpace{}

  \scrule{ISO-Procs}
  {
    \forall FS|_a^\iota, GS_b^{\iota'} \in P \text{ where } FS|_a^\iota \neq
    GS|_b^{\iota'} . \\
    a = \ocap \: \lor \: b = \ocap \implies \isolated{(H, FS, GS)}
  }
  {
    \isolation{(H, P)}
  }
  \caption{Definition of isolation}
  \label{fig:def_isolation}
\end{figure}

\begin{figure}
  \scrule{Reach1}
  {o \in \dom{(H)}}
  {\reach{(H, o, o)}}

  \RuleSpace{}

  \scrule{Reach2}
  {
    o \in \dom{(H)} \andalso H(o) = \Obj{C, FM} \\
    o'' \in \image{(FM)} \andalso \reach{(H, o'', o')}
  }
  { \reach{(H, o, o')} }
  \caption{Definition of reach}
  \label{fig:def_reach}
\end{figure}

\begin{figure}
  \scrule{AR-F}
  { (x \mapsto o) \in L }
  { \accRoot{(o, \sFrame{L}{t})} }

  \RuleSpace{}

  \scrule{AR-FS}
  { \accRoot{(o, F)} \: \lor \: \accRoot{(o, FS)} }
  { \accRoot{(o, F \circ FS)} }
  \caption{Definition of accRoot}
  \label{fig:def_accroot}
\end{figure}

\begin{figure}
  \scrule{OCR-FS}
  { a = \ocap \implies \ocrloc(FS, H) }
  { H; a \vdash FS \tsep \ocr }

  \RuleSpace{}

  \scax{OCR-PEmpty}
  {H \vdash \emptyset \tsep \ocr}

  \RuleSpace{}

  \scrule{OCR-P}
  {H \vdash P \tsep \ocr \andalso H; a \vdash FS \tsep \ocr}
  {H \vdash P \cup \left\{ FS|_a^\iota \right\} \tsep \ocr}

  \caption{Definition of OCAP reachability}
  \label{fig:def_ocapreach}
\end{figure}

\begin{figure}
  \scrule{GSep-Threads}
  {\forall FS|_a^\iota \in P. \: a = \ocap \implies \forall o \in \accRoots{(FS, H)}. \: \csep{(H, o, o_g)} }
  {H \vdash P \tsep \gsep}

  \caption{Definition of global separation}
  \label{fig:def_gsep}
\end{figure}

% TODO include the \Gamma_{\CellType} definition somewhere


% Introduce the core language with syntax, type system and state properties like
% WT heap, isolation, well typed state


