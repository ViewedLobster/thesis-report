\chapter{Core Language}
\label{cha:core_language}

In this chapter a basic core language is introduced. It will build a lot upon
the core languages of LaCasa and LVish and combine the two. In the end we will
have a object oriented language incorporating many of the features of LVish with
a type system enforcing OCAP properties, much like the system of LaCasa.

\section{Syntax}
\label{sec:syntax}

The language which we shall call Reactive Async Core Language (RACL) has a big
similarity with CLC from LaCasa. Many expressions are the same except for a few
removals and additions. The language grammar is defined in
Figure~\ref{fig:racl_grammar}. It is a simple object oriented language which is
parameterized on the lattice \LatVals{}.

\begin{figure}
  \centering
  $\begin{array}{lll@{\hspace{4mm}}l}
    p &::= &\overline{cd}~\overline{vd}~t  & \mbox{Program} \\
    cd &::= &\texttt{class}~C~\texttt{extends}~D~\{\overline{fd}~\overline{md}\}
    & \mbox{Class} \\
    vd,fd &::= &\texttt{var}~f~:~\tau & \mbox{Variable/Field} \\
    md &::= &\texttt{def}~m(x: \sigma):~\tau = t & \mbox{Method}\\
    &&&\\
    \sigma,\tau & ::= & & \mbox{Types} \\
    & & C, D & \mbox{Class types} \\ 
    &| & \CellType & \mbox{Cell type} \\
    &| & \NullType & \mbox{Null type} \\
    &| & \LatType & \mbox{Lattice value type} \\
    &&&\\
    t &::=& & \mbox{Terms} \\
    & & x & \mbox{Variable} \\
    &|& \texttt{let}~x = e~\texttt{in}~t &\mbox{Let binding} \\
    &&&\\
    e &::=& & \mbox{Expression} \\
    & & l & \mbox{Lattice value} \\
    &|& \texttt{null} & \mbox{Null reference} \\
    &|& x &\mbox{Variable} \\
    &|& x.f &\mbox{Field selection} \\
    &|& x.f = y & \mbox{Field assignment} \\
    &|& \texttt{new}~C & \mbox{Class instance creation} \\
    &|& \texttt{new}~\texttt{Cell} & \mbox{Cell instance creation} \\
    &|& x.m(y) & \mbox{Method invocation} \\
    &|& x~\texttt{put}~y & \mbox{Cell value update} \\
    &|& \texttt{when}~x~\texttt{pass}~y~\texttt{then}~(\overline{cap}, z
    \Rightarrow t) & \mbox{Dependency creation} \\
    &&&\\
    cap & ::= & x = y & \mbox{Variable capture} \\
  \end{array}$
  \caption{Grammar of RACL}
  \label{fig:racl_grammar}
\end{figure}

We can see a program $p$ consists of a sequence of class definitions
$\overline{cd}$, a sequence of variable declarations $\overline{vd}$ and a term
$t$. A class definition $cd$ as would be expected consists of a name specifier
$C$, inheritance specifier $D$, field declarations $\overline{fd}$ and method
definitions $\overline{md}$. Variable and field declarations both have the same
form consisting of a name specifier $f$ and a type $\tau$. Method definitions
are also standard, with one thing to note that all methods takes exactly one
input. More complicated inputs can be constructed using a container class.

The type specifiers $\sigma$ and $\tau$ can take on the values as specified.
Note that we have the special \CellType{} and \LatType{} types which are meant
to represent the cells of reactive async and values from the used lattice. Types
will be discussed more in Section~\ref{sec:type_system}.

As with LaCasa the terms of RACL are written in ANF (i.e.\ every expression is
named). Most of the expressions should be self explanatory, but note for example
that we have a separate instance creation expression for cells, an expression
for updating the value of a cell aswell as an expression for creating
dependencies between cells. The semantics of these will be explained in
Section~\ref{sec:semantics}.

% TODO note something about the language being parameterized on the lattice

\section{Type System}
\label{sec:type_system}

The types and type lattice of RACL is summarized in
Figure~\ref{fig:racl_typelat}. Except for the standard types we see that the
\CellType{} type is grouped under \AnyRefType{} like the class types. This
signifies that cell values are stored on the heap. We also have a separate
lattice value type \LatType{}.

\begin{figure}[]
  \centering
  \begin{tikzpicture} 
    \node (top) at (1,3) {$\top$};
    \node (anyref) at (2,2) {\AnyRefType};
    \node (cell) at (1,1) {\CellType};
    \node (classes) at (3,1) {$C,D$};
    \node (null) at (2,0) {\NullType};
    \node (lat) at (-1, 1) {\LatType};
    \node (bot) at (1, -1) {$\bot$};
    \draw (top) -- (lat) -- (bot) -- (null) -- (classes) -- (anyref) -- (top);
    \draw (anyref) -- (cell) -- (null);
  \end{tikzpicture}
  \caption{Type lattice of RACL}
  \label{fig:racl_typelat}
\end{figure}

The basic building blocks of our type system are the typing of expressions and
terms. Our type relation is written
\begin{equation}
  \TypeRel{\Gamma}{a}{t}{\tau} \quad \text{ or } \quad
  \TypeRel{\Gamma}{a}{e}{\tau}. \notag
\end{equation}
Apart from the usual parts of typing environment $\Gamma$, term $t$ or
expression $e$ and type $\tau$ we note that it includes a designator $a$ which
can take on the values \nocap{} and \ocap{}. The latter indicates that the term
or expression is typed under OCAP constraints. This is exactly like the type
system of \LaCasa{}. All typing rules for terms and expressions can be found in
Figure~\ref{fig:expr_typing}.

\begin{figure}[t]
  \centering
  %\begin{multicols}{2}
    \scrule{T-Let}
    {\TypeRel{\Gamma}{a}{e}{\tau} \andalso \TypeRel{\Gamma,x:
    \tau}{a}{t}{\sigma}}
    {\TypeRel{\Gamma}{a}{ \Let{x}{e}{t} }{\sigma}}

    \vspace{0.5em}

    \scax{T-Null}{\TypeRel{\Gamma}{a}{\NullVal}{\NullType}}

    \vspace{0.5em}

    \scax{T-LVal}{\TypeRel{\Gamma}{a}{l}{\LatType}}
    
    \vspace{0.5em}

    \scrule{T-Var}{x \in dom(\Gamma)}{\TypeRel{\Gamma}{a}{x}{\Gamma(x)}}

    \vspace{0.5em}

    \scrule{T-Select}
    {\TypeRel{\Gamma}{a}{x}{C} \andalso ftype(f, C) = \tau }
    {\TypeRel{\Gamma}{a}{\FSel{x}{f}}{\tau}}
    
    \vspace{0.5em}

    \scrule{T-Assign}
    {\TypeRel{\Gamma}{a}{x}{C} \andalso ftype(f, C) = \tau \\
    \TypeRel{\Gamma}{a}{y}{\tau'} \andalso \tau' \stof \tau }
    {\TypeRel{\Gamma}{a}{\FAss{x}{f}{y}}{\tau}}

    \vspace{0.5em}

    \scrule{T-New}
    {a = \ocap \Longrightarrow ocap(C)}
    {\TypeRel{\Gamma}{a}{\New{C}}{C}}

    \vspace{0.5em}

    \scax{T-NewCell}{\TypeRel{\Gamma}{a}{\NewCell}{\CellType}}
    
    \vspace{0.5em}

    \scrule{T-Call}
    {\TypeRel{\Gamma}{a}{x}{C} \andalso mtype(C,m) = \sigma \to \tau \\
    \TypeRel{\Gamma}{a}{y}{\sigma'} \andalso \sigma' \stof \sigma }
    {\TypeRel{\Gamma}{a}{\Call{x}{m}{y}}{\tau}}
    
    \vspace{0.5em}

    \scrule{T-Put}
    {\TypeRel{\Gamma}{a}{x}{\CellType} \andalso \TypeRel{\Gamma}{a}{y}{\LatType}}
    {\TypeRel{\Gamma}{a}{\Put{x}{y}}{\CellType}}
    
    \vspace{0.5em}

    \scrule{T-When}
    {\TypeRel{\Gamma}{a}{x}{\CellType} \andalso \TypeRel{\Gamma}{a}{y}{\LatType} \\
    \forall \Capt{u}{u'} \in \overline{cap}. \; \TypeRel{\Gamma}{a}{u'}{\CellType}\\
    \Gamma_{cells} = [u \mapsto \CellType : \Capt{u}{u'} \in \overline{cap}]\\
    \TypeRel{\Gamma_{cells}, z : \LatType}{\ocap}{t}{\sigma}}
    { \TypeRel{\Gamma}{a}{\When{x}{y}{ \CB{\overline{cap}}{z}{t}}}{\CellType} }

    
    \RuleSpace{}

    \scrule{T-SubT}
    {\TypeRel{\Gamma}{a}{e}{\sigma'} \andalso \sigma' \stof \sigma}
    {\TypeRel{\Gamma}{a}{e}{\sigma}}
  %\end{multicols}
  \caption{\RACL{} typing rules for expressions and terms.}
  \label{fig:expr_typing}
\end{figure}

\begin{figure}
  \scrule{WF-Prog}
  {p \vdash \overline{cd} \andalso p \vdash \Gamma_0 \andalso
  \TypeRel{\Gamma_0}{\nocap}{t}{\tau}}
  {p \vdash \overline{cd} \: \overline{vd} \: t}

  \RuleSpace{}

  \scrule{WF-Class}
  {C \vdash \overline{md} \\ D = \AnyRefType{} \lor
  p \vdash \ClassDef{D}{...}{...}{...} \\
  \forall (\MethodDef{m}{...}{...}{...}{...}) \in \overline{md} . \: override(m,
  C, D) \\
  \forall (\VarDecl{f}{\tau}) \in \overline{vd} . \: f \notin fields(D) }
  {p \vdash \ClassDef{C}{D}{\overline{vd}}{\overline{md}}}

  \RuleSpace{}

  \scrule{WF-Override}
  {mtype(m, D)\text{ not def. } \lor mtype(m, C) = mtype(m, D)}
  {override(m, C, D)}
  
  \RuleSpace{}

  \scrule{WF-Method}
  { \TypeRel{\Gamma_0, \This:C, x : \sigma}{\nocap}{t}{\tau'} \\
  \tau' \stof \tau}
  {C \vdash \MethodDef{m}{x}{\sigma}{\tau}{t}}
  \caption{\RACL{} rules for well formedness of programs.}
  \label{fig:wf_typing}
\end{figure}


\begin{figure}
  \scax{OCAP-AnyRef}
  {\ocap{(\AnyRefType{})}}

  \RuleSpace{}

  \scrule{OCAP-Class}
  {\ocap{(D)} \andalso C \vdash_{\ocap} \overline{md} \\
  \forall (\VarDecl{f}{\sigma}) \in \overline{vd}. \: ocap(\sigma)}
  {\ocap{(C)}}

  \RuleSpace{}

  \scrule{OCAP-Method}
  {\TypeRel{\This : C, x : \sigma}{\ocap}{t}{\tau'} \\
  \tau' \stof \tau}
  {C \vdash_{\ocap} \MethodDef{m}{x}{\sigma}{\tau}{t}}
  \caption{\RACL{} OCAP rules.}
  \label{fig:ocap_typing}
\end{figure}


\section{Semantics}
\label{sec:semantics}

\begin{figure}
  \scax{E-Null}
  {H, \sFrame{L}{\Let{x}{\NullVal}{t}} \; \FRedTo \; H, \sFrame{L[x \mapsto
  \NullVal]}{t}}

  \RuleSpace{}

  \scax{E-LVal}
  {H, \sFrame{L}{\Let{x}{l}{t}} \; \FRedTo \; H, \sFrame{L[x \mapsto
  l]}{t}}

  \RuleSpace{}

  \scax{E-Var}
  {H, \sFrame{L}{\Let{x}{y}{t}} \; \FRedTo \; H, \sFrame{L[x \mapsto
  L(y)]}{t}}

  \RuleSpace{}

  \scrule{E-Select}
  {L(y) = o \andalso H(o) = \Obj{C, FM} \andalso f \in dom(FM)}
  {H, \sFrame{L}{\Let{x}{ \FSel{y}{f} }{t}} \; \FRedTo  \\ 
  H, \sFrame{L[x \mapsto FM(f)]}{t}}

  \RuleSpace{}

  \scrule{E-Assign}
  {L(y) = o \andalso H(o) = \Obj{C, FM} \andalso f \in dom(FM) \\
  FM' = FM[f \mapsto L(z)] \andalso H' = H[o \mapsto \Obj{C, FM'}]}
  {H, \sFrame{L}{\Let{x}{\FAss{y}{f}{z}}{t}} \; \FRedTo \\
   H', \sFrame{L[x \mapsto L(z)]}{t}}

  \RuleSpace{}

  \scrule{E-New}
  {o\text{ fresh} \\
  FM = [f \mapsto bot(\sigma): (\VarDecl{f}{\sigma}) \in fields(C)] \\
  H' = H[o \mapsto \Obj{C, FM}]}
  {H, \sFrame{L}{ \Let{x}{\New{C}}{t} } \; \FRedTo \\
  H', \sFrame{L[x \mapsto o]}{t}}
  
  \RuleSpace{}

  \scrule{E-New}
  {o\text{ fresh} \andalso
  H' = H[o \mapsto \Cell{\emptyset, \bot_{\LatVals{}}}]}
  {H, \sFrame{L}{ \Let{x}{\NewCell}{t} } \; \FRedTo \\
  H', \sFrame{L[x \mapsto o]}{t}}

  \RuleSpace{}
  
  \scrule{E-Put}
  {L(y) = o \andalso H(o) = \Cell{DEP, l} \\
  L(z) = l' \andalso c' = \Cell{DEP, l \sqcup l'} \\
  H' = H[o \mapsto c']}
  {H, \sFrame{L}{\Let{x}{\Put{y}{z}}{t}} \; \FRedTo \\
  H', \sFrame{L[x \mapsto L(y)]}{t}}

  \RuleSpace{}

  \scrule{E-When}
  {L(x) = o \andalso H(o) = \Cell{DEP, l} \andalso L(y) = l' \\
  L_{\text{env}} = [u \mapsto L(u') : (\Capt{u}{u'}) \in \overline{cap}] \\
  cb = (L_{\text{env}}, z \Rightarrow t') \andalso DEP' = DEP \cup_+ (l', cb) \\
  H' = H[o \mapsto \Cell{DEP', l}] }
  { H, \sFrame{L}{ \Let{x}{ \When{y}{z}{ (\overline{cap}, z \Rightarrow t') }}{t} } \\ \FRedTo \;
  H', \sFrame{L[x \mapsto L(y)]}{t} }
  \caption{\RACL{} single frame reduction rules.}
  \label{fig:frame_red_rulesj}
\end{figure}

\begin{figure}
  % TODO add these rules (null pointer exception rules)
  \scrule{E-NullSelect}
  {L(y) = \NullVal}
  {H, \sFrame{L, \Let{x}{\FSel{y}{f}}{t} } \; \FRedTo \; \Error}

  \RuleSpace{}

  \scrule{E-NullAssign}
  {L(y) = \NullVal}
  {H, \sFrame{L, \Let{x}{\FAss{y}{f}{z}}{t} } \; \FRedTo \; \Error}

  \RuleSpace{}

  \scrule{E-NullCall}
  {L(y) = \NullVal}
  {H, \sFrame{L, \Let{x}{\Call{y}{m}{z}}{t} } \; \FRedTo \; \Error}

  \RuleSpace{}

  \scrule{E-NullWhen}
  {L(y) = \NullVal}
  {H, \sFrame{L}{\Let{x}{  \When{y}{z}{ (\overline{cap}, w \Rightarrow t')}}{t}
  }  \\ \FRedTo \; \Error}
  \caption{\RACL{} error spawning rules.}
  \label{fig:error_red_rules}
\end{figure}

\begin{figure}
  \scrule{E-Call}
  {
    L(y) = o \andalso H(o) = \Obj{C, FM} \\
    methodBody(m, C) = w \to t' \\
    L_{\text{base}} =
    \begin{cases}
      \emptyset & \text{if } a = \ocap \\
      L_0 & \text{if } a = \nocap
    \end{cases} \\
    L' = L_{\text{base}}[\This \mapsto L(y), w \mapsto L(y)] 
  }
  {H, \sFrame{L}{ \Let{x}{ \Call{y}{m}{z} }{t} } \circ FS |_a^\alpha \; \FSRedTo \\
  H, \Frame{L'}{t'}{x} \circ \sFrame{L}{t} \circ FS |_a^\alpha }

  \RuleSpace{}

  \scax{E-Ret}
  {H, \Frame{L'}{x}{y} \circ \sFrame{L, t} \circ FS |_a^\alpha \; \FSRedTo \\
  H, \sFrame{L[y \mapsto L'(x)]}{t} \circ FS |_a^\alpha }

  \RuleSpace{}

  \scrule{E-FProp}
  {H, F \; \FRedTo \; H', F'}
  {H, F \circ FS |_a^\alpha \; \FSRedTo \; H', F' \circ FS |_a^\alpha }

  \RuleSpace{}
  
  \scrule{E-ErrorFS}
  {H, F \; \FRedTo \; \Error }
  {H, F \circ FS |_a^\alpha \; \FSRedTo \; \Error}

  \caption{\RACL{} frame stack reduction rules.}
  \label{fig:fs_red_rules}
\end{figure}

\begin{figure}
  \caption{\RACL{} thread set reduction rules.}
  \label{fig:thread_red_rules}
\end{figure}

\section{Properties}
\label{sec:properties}


% Introduce the core language with syntax, type system and state properties like
% WT heap, isolation, well typed state


