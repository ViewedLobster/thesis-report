\chapter{Core Language}
\label{cha:core_language}

In this chapter a basic core language is introduced. It will build a lot upon
the core languages of LaCasa and LVish and combine the two. In the end we will
have a object oriented language incorporating many of the features of LVish with
a type system enforcing OCAP properties, much like the system of LaCasa.

\section{Syntax}
\label{sec:syntax}

The language which we shall call Reactive Async Core Language (RACL) has a big
similarity with CLC from LaCasa. Many expressions are the same except for a few
removals and additions. The language grammar is defined in
Figure~\ref{fig:racl_grammar}. It is a simple object oriented language which is
parameterized on the lattice \LatVals{}.

\begin{figure}
  \centering
  $\begin{array}{lll@{\hspace{4mm}}l}
    p &::= &\overline{cd}~\overline{vd}~t  & \mbox{Program} \\
    cd &::= &\texttt{class}~C~\texttt{extends}~D~\{\overline{fd}~\overline{md}\}
    & \mbox{Class} \\
    vd,fd &::= &\texttt{var}~f~:~\tau & \mbox{Variable/Field} \\
    md &::= &\texttt{def}~m(x: \sigma):~\tau = t & \mbox{Method}\\
    &&&\\
    \sigma,\tau & ::= & & \mbox{Types} \\
    & & C, D & \mbox{Class types} \\ 
    &| & \CellType & \mbox{Cell type} \\
    &| & \NullType & \mbox{Null type} \\
    &| & \LatType & \mbox{Lattice value type} \\
    &&&\\
    t &::=& & \mbox{Terms} \\
    & & x & \mbox{Variable} \\
    &|& \texttt{let}~x = e~\texttt{in}~t &\mbox{Let binding} \\
    &&&\\
    e &::=& & \mbox{Expression} \\
    & & l & \mbox{Lattice value} \\
    &|& \texttt{null} & \mbox{Null reference} \\
    &|& x &\mbox{Variable} \\
    &|& x.f &\mbox{Field selection} \\
    &|& x.f = y & \mbox{Field assignment} \\
    &|& \texttt{new}~C & \mbox{Class instance creation} \\
    &|& \texttt{new}~\texttt{Cell} & \mbox{Cell instance creation} \\
    &|& x.m(y) & \mbox{Method invocation} \\
    &|& x~\texttt{put}~y & \mbox{Cell value update} \\
    &|& \texttt{when}~x~\texttt{pass}~y~\texttt{then}~(\overline{cap}, z
    \Rightarrow t) & \mbox{Dependency creation} \\
    &&&\\
    cap & ::= & x = y & \mbox{Variable capture} \\
  \end{array}$
  \caption{Grammar of RACL}
  \label{fig:racl_grammar}
\end{figure}

We can see a program $p$ consists of a sequence of class definitions
$\overline{cd}$, a sequence of variable declarations $\overline{vd}$ and a term
$t$. A class definition $cd$ as would be expected consists of a name specifier
$C$, inheritance specifier $D$, field declarations $\overline{fd}$ and method
definitions $\overline{md}$. Variable and field declarations both have the same
form consisting of a name specifier $f$ and a type $\tau$. Method definitions
are also standard, with one thing to note that all methods takes exactly one
input. More complicated inputs can be constructed using a container class.

The type specifiers $\sigma$ and $\tau$ can take on the values as specified.
Note that we have the special \CellType{} and \LatType{} types which are meant
to represent the cells of reactive async and values from the used lattice. Types
will be discussed more in Section~\ref{sec:type_system}.

As with LaCasa the terms of RACL are written in ANF (i.e.\ every expression is
named). Most of the expressions should be self explanatory, but note for example
that we have a separate instance creation expression for cells, an expression
for updating the value of a cell aswell as an expression for creating
dependencies between cells. The semantics of these will be explained in
Section~\ref{sec:semantics}.

% TODO note something about the language being parameterized on the lattice

\section{Type System}
\label{sec:type_system}

The types and type lattice of RACL is summarized in
Figure~\ref{fig:racl_typelat}. Except for the standard types we see that the
\CellType{} type is grouped under \AnyRefType{} like the class types. This
signifies that cell values are stored on the heap. We also have a separate
lattice value type \LatType{}.

\begin{figure}[]
  \centering
  \begin{tikzpicture} 
    \node (top) at (1,3) {$\top$};
    \node (anyref) at (2,2) {\AnyRefType};
    \node (cell) at (1,1) {\CellType};
    \node (classes) at (3,1) {$C,D$};
    \node (null) at (2,0) {\NullType};
    \node (lat) at (-1, 1) {\LatType};
    \node (bot) at (1, -1) {$\bot$};
    \draw (top) -- (lat) -- (bot) -- (null) -- (classes) -- (anyref) -- (top);
    \draw (anyref) -- (cell) -- (null);
  \end{tikzpicture}
  \caption{Type lattice of RACL}
  \label{fig:racl_typelat}
\end{figure}

The basic building blocks of our type system are the typing of expressions and
terms. Our type relation is written
\begin{equation}
  \TypeRel{\Gamma}{a}{t}{\tau} \quad \text{ or } \quad
  \TypeRel{\Gamma}{a}{e}{\tau}. \notag
\end{equation}
Apart from the usual parts of typing environment $\Gamma$, term $t$ or
expression $e$ and type $\tau$ we note that it includes a designator $a$ which
can take on the values \nocap{} and \ocap{}. The latter indicates that the term
or expression is typed under OCAP constraints. This is exactly like the type
system of \LaCasa{}. All typing rules for terms and expressions can be found in
Figure~\ref{fig:expr_typing}.

\begin{figure}[t]
  \centering
  %\begin{multicols}{2}
    \scrule{T-Let}
    {\TypeRel{\Gamma}{a}{e}{\tau} \andalso \TypeRel{\Gamma,x:
    \tau}{a}{t}{\sigma}}
    {\TypeRel{\Gamma}{a}{ \Let{x}{e}{t} }{\sigma}}

    \vspace{0.5em}

    \scax{T-Null}{\TypeRel{\Gamma}{a}{\NullVal}{\NullType}}

    \vspace{0.5em}

    \scax{T-LVal}{\TypeRel{\Gamma}{a}{l}{\LatType}}
    
    \vspace{0.5em}

    \scrule{T-Var}{x \in dom(\Gamma)}{\TypeRel{\Gamma}{a}{x}{\Gamma(x)}}

    \vspace{0.5em}

    \scrule{T-Select}
    {\TypeRel{\Gamma}{a}{x}{C} \andalso ftype(f, C) = \tau }
    {\TypeRel{\Gamma}{a}{\FSel{x}{f}}{\tau}}
    
    \vspace{0.5em}

    \scrule{T-Assign}
    {\TypeRel{\Gamma}{a}{x}{C} \andalso ftype(f, C) = \tau \\
    \TypeRel{\Gamma}{a}{y}{\tau'} \andalso \tau' \stof \tau }
    {\TypeRel{\Gamma}{a}{\FAss{x}{f}{y}}{\tau}}

    \vspace{0.5em}

    \scrule{T-New}
    {a = \ocap \Longrightarrow ocap(C)}
    {\TypeRel{\Gamma}{a}{\New{C}}{C}}

    \vspace{0.5em}

    \scax{T-NewCell}{\TypeRel{\Gamma}{a}{\NewCell}{\CellType}}
    
    \vspace{0.5em}

    \scrule{T-Call}
    {\TypeRel{\Gamma}{a}{x}{C} \andalso mtype(C,m) = \sigma \to \tau \\
    \TypeRel{\Gamma}{a}{y}{\sigma'} \andalso \sigma' \stof \sigma }
    {\TypeRel{\Gamma}{a}{\Call{x}{m}{y}}{\tau}}
    
    \vspace{0.5em}

    \scrule{T-Put}
    {\TypeRel{\Gamma}{a}{x}{\CellType} \andalso \TypeRel{\Gamma}{a}{y}{\LatType}}
    {\TypeRel{\Gamma}{a}{\Put{x}{y}}{\CellType}}
    
    \vspace{0.5em}

    \scrule{T-When}
    {\TypeRel{\Gamma}{a}{x}{\CellType} \andalso \TypeRel{\Gamma}{a}{y}{\LatType} \\
    \forall \Capt{u}{u'} \in \overline{cap}. \; \TypeRel{\Gamma}{a}{u'}{\CellType}\\
    \Gamma_{cells} = [u \mapsto \CellType : \Capt{u}{u'} \in \overline{cap}]\\
    \TypeRel{\Gamma_{cells}, z : \LatType}{\ocap}{t}{\sigma}}
    { \TypeRel{\Gamma}{a}{\When{x}{y}{ \CB{\overline{cap}}{z}{t}}}{\CellType} }

    
    \RuleSpace{}

    \scrule{T-SubT}
    {\TypeRel{\Gamma}{a}{e}{\sigma'} \andalso \sigma' \stof \sigma}
    {\TypeRel{\Gamma}{a}{e}{\sigma}}
  %\end{multicols}
  \caption{\RACL{} typing rules for expressions and terms.}
  \label{fig:expr_typing}
\end{figure}

\begin{figure}
  \scrule{WF-Prog}
  {p \vdash \overline{cd} \andalso p \vdash \Gamma_0 \andalso
  \TypeRel{\Gamma_0}{\nocap}{t}{\tau}}
  {p \vdash \overline{cd} \: \overline{vd} \: t}

  \RuleSpace{}

  \scrule{WF-Class}
  {C \vdash \overline{md} \\ D = \AnyRefType{} \lor
  p \vdash \ClassDef{D}{...}{...}{...} \\
  \forall (\MethodDef{m}{...}{...}{...}{...}) \in \overline{md} . \: override(m,
  C, D) \\
  \forall (\VarDecl{f}{\tau}) \in \overline{vd} . \: f \notin fields(D) }
  {p \vdash \ClassDef{C}{D}{\overline{vd}}{\overline{md}}}

  \RuleSpace{}

  \scrule{WF-Override}
  {mtype(m, D)\text{ not def. } \lor mtype(m, C) = mtype(m, D)}
  {override(m, C, D)}
  
  \RuleSpace{}

  \scrule{WF-Method}
  { \TypeRel{\Gamma_0, \This:C, x : \sigma}{\nocap}{t}{\tau'} \\
  \tau' \stof \tau}
  {C \vdash \MethodDef{m}{x}{\sigma}{\tau}{t}}
  \caption{\RACL{} rules for well formedness of programs.}
  \label{fig:wf_typing}
\end{figure}


\begin{figure}
  \scax{OCAP-AnyRef}
  {\ocap{(\AnyRefType{})}}

  \RuleSpace{}

  \scax{OCAP-Cell}
  {\ocap(\CellType)}

  \RuleSpace{}

  \scrule{OCAP-Class}
  {\ocap{(D)} \andalso C \vdash_{\ocap} \overline{md} \\
  \forall (\VarDecl{f}{\sigma}) \in \overline{vd}. \: ocap(\sigma)}
  {\ocap{(C)}}

  \RuleSpace{}

  \scrule{OCAP-Method}
  {\TypeRel{\This : C, x : \sigma}{\ocap}{t}{\tau'} \\
  \tau' \stof \tau}
  {C \vdash_{\ocap} \MethodDef{m}{x}{\sigma}{\tau}{t}}
  \caption{\RACL{} OCAP rules.}
  \label{fig:ocap_typing}
\end{figure}


\section{Semantics}
\label{sec:semantics}

\begin{figure}
  \scax{E-Null}
  {H, \sFrame{L}{\Let{x}{\NullVal}{t}} \; \FRedTo \; H, \sFrame{L[x \mapsto
  \NullVal]}{t}}

  \RuleSpace{}

  \scax{E-LVal}
  {H, \sFrame{L}{\Let{x}{l}{t}} \; \FRedTo \; H, \sFrame{L[x \mapsto
  l]}{t}}

  \RuleSpace{}

  \scax{E-Var}
  {H, \sFrame{L}{\Let{x}{y}{t}} \; \FRedTo \; H, \sFrame{L[x \mapsto
  L(y)]}{t}}

  \RuleSpace{}

  \scrule{E-Select}
  {L(y) = o \andalso H(o) = \Obj{C, FM} \andalso f \in dom(FM)}
  {H, \sFrame{L}{\Let{x}{ \FSel{y}{f} }{t}} \; \FRedTo  \\ 
  H, \sFrame{L[x \mapsto FM(f)]}{t}}

  \RuleSpace{}

  \scrule{E-Assign}
  {L(y) = o \andalso H(o) = \Obj{C, FM} \andalso f \in dom(FM) \\
  FM' = FM[f \mapsto L(z)] \andalso H' = H[o \mapsto \Obj{C, FM'}]}
  {H, \sFrame{L}{\Let{x}{\FAss{y}{f}{z}}{t}} \; \FRedTo \\
   H', \sFrame{L[x \mapsto L(z)]}{t}}

  \RuleSpace{}

  \scrule{E-New}
  {o\text{ fresh} \\
  FM = [f \mapsto bot(\sigma): (\VarDecl{f}{\sigma}) \in fields(C)] \\
  H' = H[o \mapsto \Obj{C, FM}]}
  {H, \sFrame{L}{ \Let{x}{\New{C}}{t} } \; \FRedTo \\
  H', \sFrame{L[x \mapsto o]}{t}}
  
  \RuleSpace{}

  \scrule{E-New}
  {o\text{ fresh} \andalso
  H' = H[o \mapsto \Cell{\emptyset, \bot_{\LatVals{}}}]}
  {H, \sFrame{L}{ \Let{x}{\NewCell}{t} } \; \FRedTo \\
  H', \sFrame{L[x \mapsto o]}{t}}

  \RuleSpace{}
  
  \scrule{E-Put}
  {L(y) = o \andalso H(o) = \Cell{DEP, l} \\
  L(z) = l' \andalso c' = \Cell{DEP, l \sqcup l'} \\
  H' = H[o \mapsto c']}
  {H, \sFrame{L}{\Let{x}{\Put{y}{z}}{t}} \; \FRedTo \\
  H', \sFrame{L[x \mapsto L(y)]}{t}}

  \RuleSpace{}

  % TODO fix the variable names
  \scrule{E-When}
  {L(y) = o \andalso H(o) = \Cell{DEP, l} \andalso L(z) = l' \\
  L_{\text{env}} = [u \mapsto L(u') : (\Capt{u}{u'}) \in \overline{cap}]
  \andalso cb = (L_{\text{env}}, w \Rightarrow t') \\
  d\text{ fresh thread id } \andalso DEP' = DEP \cup (l', cb)^d \\
  H' = H[o \mapsto \Cell{DEP', l}] }
  { H, \sFrame{L}{ \Let{x}{ \When{y}{z}{ (\overline{cap}, w \Rightarrow t') }}{t} } \\ \FRedTo \;
  H', \sFrame{L[x \mapsto L(y)]}{t} }
  \caption{\RACL{} single frame reduction rules.}
  \label{fig:frame_red_rules}
\end{figure}

\begin{figure}
  % TODO add these rules (null pointer exception rules)
  \scrule{E-NullSelect}
  {L(y) = \NullVal}
  {H, \sFrame{L, \Let{x}{\FSel{y}{f}}{t} } \; \FRedTo \; \Error}

  \RuleSpace{}

  \scrule{E-NullAssign}
  {L(y) = \NullVal}
  {H, \sFrame{L, \Let{x}{\FAss{y}{f}{z}}{t} } \; \FRedTo \; \Error}

  \RuleSpace{}

  \scrule{E-NullCall}
  {L(y) = \NullVal}
  {H, \sFrame{L, \Let{x}{\Call{y}{m}{z}}{t} } \; \FRedTo \; \Error}

  \RuleSpace{}

  \scrule{E-NullWhen}
  {L(y) = \NullVal}
  {H, \sFrame{L}{\Let{x}{  \When{y}{z}{ (\overline{cap}, w \Rightarrow t')}}{t}
  }  \\ \FRedTo \; \Error}
  \caption{\RACL{} error spawning rules.}
  \label{fig:error_red_rules}
\end{figure}

\begin{figure}
  \scrule{E-Call}
  {
    L(y) = o \andalso H(o) = \Obj{C, FM} \\
    methodBody(m, C) = w \to t' \\
    L_{\text{base}} =
    \begin{cases}
      \emptyset & \text{if } a = \ocap \\
      L_0 & \text{if } a = \nocap
    \end{cases} \\
    L' = L_{\text{base}}[\This \mapsto L(y), w \mapsto L(y)] 
  }
  {H, \sFrame{L}{ \Let{x}{ \Call{y}{m}{z} }{t} } \circ FS |_a^\alpha \; \FSRedTo \\
  H, \Frame{L'}{t'}{x} \circ \sFrame{L}{t} \circ FS |_a^\alpha }

  \RuleSpace{}

  \scax{E-Ret}
  {H, \Frame{L'}{x}{y} \circ \sFrame{L, t} \circ FS |_a^\alpha \; \FSRedTo \\
  H, \sFrame{L[y \mapsto L'(x)]}{t} \circ FS |_a^\alpha }

  \RuleSpace{}

  \scrule{E-FProp}
  {H, F \; \FRedTo \; H', F'}
  {H, F \circ FS |_a^\alpha \; \FSRedTo \; H', F' \circ FS |_a^\alpha }

  \RuleSpace{}
  
  \scrule{E-ErrorFS}
  {H, F \; \FRedTo \; \Error }
  {H, F \circ FS |_a^\alpha \; \FSRedTo \; \Error}

  \caption{\RACL{} frame stack reduction rules.}
  \label{fig:fs_red_rules}
\end{figure}

\begin{figure}
  \scrule{E-Spawn}
  {
    o \in dom(H) \andalso H(o) = \Cell{DEP, l} \\ 
    l' \sqsubseteq l \andalso (l', cb)^d \in DEP \andalso cb = (L_{\text{env}}, z
    \Rightarrow t) \\
    L = L_{\text{env}}[z \mapsto l'] \\
    H' = H[o \mapsto \Cell{DEP - (l', cb), l}]
  }
  {
    H,P \Rrightarrow H', P \cup \left\{ \Frame{L}{t}{-} \circ \varepsilon
    |_{\ocap}^{d} \right\}
  }

  \RuleSpace{}

  \scrule{E-Term}
  {P = P' \cup_d \left\{ \sFrame{L}{x} \circ \varepsilon |_a^d \right\} }
  {H,P \Rrightarrow H, P'}

  \RuleSpace{}

  \scrule{E-FSProp}
  {H, FS \twoheadrightarrow H', FS'}
  {H, P \cup_d \left\{ FS \right\} \Rrightarrow H', P \cup \left\{ FS' \right\} }

  \RuleSpace{}

  \scrule{E-ErrorP}
  {H, FS \twoheadrightarrow \Error}
  {H, P \cup_d \left\{ FS \right\} \Rrightarrow \Error }
  \caption{\RACL{} thread set reduction rules.}
  \label{fig:threads_red_rules}
\end{figure}

\section{Properties}
\label{sec:properties}

\begin{definition}
  The function typeOf is defined as follows:

  \begin{equation}
    \typeOf{(k, H)} =
    \begin{cases}
      \LatType, &\text{ if }k \in \LatVals \\
      \NullType, &\text{ if }k = \NullVal \\
      \CellType, &\text{ if }k \in \dom{(H)}\text{ and } H(k) = \Cell{...} \\
      C, &\text{ if }k \in \dom{(H)}\text{ and } H(k) = \Obj{C, ...} \\
      \ErrType, &\text{ otherwise.}
    \end{cases}
  \end{equation}
\end{definition}


\begin{definition}{(Well typed heap)}
  A heap $H$ is well typed, written $\vdash{H}$, if
  $\forall o \in \dom{(H)}$:

  If $H(o) = \Obj{C, FM}$ then
  \begin{align}
    \label{eq:class_ok}
    \forall f &\in \fields{(C)}. \notag\\ 
    &f \in \dom{(FM)} \: \land \notag\\ &\typeOf{(FM(f), H)} \stof \ftype{(f, C)}
  \end{align}
  and if $H(o) = \Cell{DEP, l}$ then
  \begin{align}
    \label{eq:cell_ok}
    \forall (l'&, (L_{\text{env}}, z \Rightarrow t))^d \in DEP. \notag\\
    &\forall (x \mapsto k) \in L_{\text{env}}.\: \typeOf{(k, H)} \stof
    \CellType \: \land \notag\\
    &\TypeRel{\Gamma_{\CellType{}}(L_{\text{env}}), z:
    \LatType}{\ocap}{t}{\gamma} 
  \end{align}
\end{definition}


\begin{definition}{(Class Object Separation)}
  For any heap $H$ and heap references $o, o'$ we have class object separation,
  $\csep{(H, o, o')}$ iff
  \begin{align}
    \label{eq:csep_def}
    \forall q, q' &\in \dom{(H)}. \notag\\
    & \reach{(H, o, q)} \: \land \: \reach{(H, o', q')} \implies \notag\\ 
    &q \neq q' \: \lor \typeOf{(q, H)} = \CellType
  \end{align}
\end{definition}

\begin{definition}{(Accessible Roots)}
  For a heap $H$ and a frame stack $FS$ we define $\accRoots{(FS, H)}$ as

  \begin{equation}
    \accRoots{(FS, H)} = \left\{ o \in \dom{(H)}: \accRoot{(o, FS)} \right\}
  \end{equation}
\end{definition}

\begin{definition}{(OCAP reachability)}
  For a heap $H$ and frame stack $FS$ we have $\ocrloc{(FS,H)}$ iff
  \begin{align}
    \label{eq:ocr_def}
    \forall o \in \: &\accRoots(FS,H), o' \in \dom(H). \notag\\
    &\reach{(H, o, o')} \implies \ocap{(\typeOf{(o', H)})}
  \end{align}
\end{definition}

\begin{definition}{(Well Typed States)}
  A state $S$ is a value of either $\Error$ or a pair $H, P$ where $H$ is a heap
  and $P$ is a set of threads. For a state $S$ we say that it is well typed,
  written
  \begin{equation}
    \vdash S \tsep \stateok
  \end{equation}
  if $S = \Error$ or $S = H, P$ and
  \begin{align}
    \vdash H \andalso H \vdash P \andalso H \vdash P \tsep \ocr \andalso \isolation{(H, P)}
    \andalso H \vdash P \tsep \gsep
  \end{align}
  
\end{definition}

\begin{figure}
  \scrule{WF-EnvVar}
  {\typeOf{(L(x), H) \stof \Gamma{(x)}}}
  { H \vdash \Gamma; L; x }

  \RuleSpace{}

  \scrule{WF-Env}
  {\dom{(\Gamma)} \subseteq \dom{(L)} \\
    \forall x \in \dom{(\Gamma)}. \: H \vdash \Gamma; L; x 
  }
  { H \vdash \Gamma; L }

  \caption{Rules for classifying local environments $L$ as well typed.}
  \label{fig:local_typing}
\end{figure}

\begin{figure}
  \scax{T-FSEmpty}
  {H; a \vdash^{x : \sigma} \varepsilon}

  \RuleSpace{}

  \scrule{T-FS1}
  { F = \Frame{L}{t}{x} \andalso H \vdash \Gamma; L \\
  \TypeRel{\Gamma}{a}{t}{\sigma} \andalso H; a \vdash^{x: \sigma} FS }
  { H; a \vdash F \circ FS }
  
  \RuleSpace{}

  \scrule{T-FS2}
  { F = \Frame{L}{t}{y} \andalso H \vdash \Gamma; L \\
  \TypeRel{\Gamma, x: \sigma}{a}{t}{\tau} \andalso H; a \vdash^{y: \tau} FS }
  { H; a \vdash^{x: \sigma} F \circ FS }

  \caption{Rules for typing frame stacks under some heap $H$ and effect $a$.}
  \label{fig:fs_typing}
\end{figure}

\begin{figure}
  \scax{T-Empty}
  {H \vdash \emptyset}

  \RuleSpace{}

  \scrule{T-Procs}
  { H; a \vdash FS \andalso H \vdash P }
  { H \vdash P \cup \left\{FS |_a^d \right\} }

  \caption{Rules for typing thread sets and the special value \Error{} under some heap $H$.}
  \label{fig:ts_typing}
\end{figure}

\begin{figure}
  \scrule{ISO-FS}
  { 
    \forall o, o' \in \dom{(H)} . \\
    \accRoot{(o, FS)} \land \accRoot{(o', GS)} \implies \csep{(H, o, o')}
  }
  {
    \isolated{(H, FS, GS)}
  }
  
  \RuleSpace{}

  \scrule{ISO-Procs}
  {
    \forall FS|_a^d, GS_b^e \in P \text{ where } FS|_a^d \neq GS|_b^e . \\
    a = \ocap \: \lor \: b = \ocap \implies \isolated{(H, FS, GS)}
  }
  {
    \isolation{(H, P)}
  }
  \caption{Definition of isolation}
  \label{fig:def_isolation}
\end{figure}

\begin{figure}
  \scrule{Reach1}
  {o \in \dom{(H)}}
  {\reach{(H, o, o)}}

  \RuleSpace{}

  \scrule{Reach2}
  {
    o \in \dom{(H)} \andalso H(o) = \Obj{C, FM} \\
    o'' \in \image{(FM)} \andalso \reach{(H, o'', o')}
  }
  { \reach{(H, o, o')} }
  \caption{Definition of reach}
  \label{fig:def_reach}
\end{figure}

\begin{figure}
  \scrule{AR-F}
  { (x \mapsto o) \in L }
  { \accRoot{(o, \sFrame{L}{t})} }

  \RuleSpace{}

  \scrule{AR-FS}
  { \accRoot{(o, F)} \: \lor \: \accRoot{(o, FS)} }
  { \accRoot{(o, F \circ FS)} }
  \caption{Definition of accRoot}
  \label{fig:def_accroot}
\end{figure}

\begin{figure}
  \scrule{OCR-FS}
  { a = \ocap \implies \ocrloc(FS, H) }
  { H; a \vdash FS \tsep \ocr }

  \RuleSpace{}

  \scax{OCR-PEmpty}
  {H \vdash \emptyset \tsep \ocr}

  \RuleSpace{}

  \scrule{OCR-P}
  {H \vdash P \tsep \ocr \andalso H; a \vdash FS \tsep \ocr}
  {H \vdash P \cup \left\{ FS|_a^d \right\} \tsep \ocr}

  \caption{Definition of OCAP reachability}
  \label{fig:def_ocapreach}
\end{figure}
% TODO define \ocrloc

\begin{figure}
  \scrule{GSep-FS}
  {a = \ocap \implies \forall o \in \accRoots{(FS, H)}. \: \csep{(H, o, o_g)} }
  {H;a \vdash FS \tsep \gsep}

  \RuleSpace{}

  \scrule{GSep-Threads}
  {\forall FS|_a^d \in P. \: H;a \vdash FS \tsep \gsep}
  {H \vdash P \tsep \gsep}

  \caption{Definition of global separation}
  \label{fig:def_gsep}
\end{figure}

% TODO include the \Gamma_{\CellType} definition somewhere


% Introduce the core language with syntax, type system and state properties like
% WT heap, isolation, well typed state


