\chapter{Introduction \& Motivation}
\label{cha:introduction}

The main approach to achieving concurrency in general applications has long been
to use locks and similar constructs in order to locally synchronize data
accesses. The major drawback with this is that it demands a lot of effort from
the programmer in order to achieve good parallelization, even of simple tasks.
Furthermore the likelihood of concurrency related errors such as deadlocks, data
races and livelocks naturally becomes higher. 

% TODO give some example of a dangerous situation using pseudo code

Concurrent deterministic programs are concurrent programs which always produce
the same results for the same inputs. This is attractive since it provides
reproducible computations.  Deterministic-by-design concurrent programming
models are systems which guarantees this property at compile time and thus
significantly simplifies concurrent programming. This greatly eases effort
from the programmer. 

% TODO give an example using some reactive async-like pseudo code

A novel deterministic-by-design model call LVish ~\parencite{kuper2013lvars,
kuper2014freeze} has been introduced.  It uses data types that fulfill the
condition of being part of a lattice, or more explicitly, having some partial
order defined on its values. By defining a join operation on the values and only
allowing writes to the data in form of this operation, you can achieve concurrent
determinism with very high parallelism using event based computation.  This is
also the basic approach of the Reactive Async
project~\parencite{conf/scala/HallerGES16}, which has shown potential to speed up
e.g.\ static analysis of source code. The main problem with Reactive Async as
of now, is that it does not include any construct to ensure that data races
between event handlers do not occur. Futhermore, there are also more fundamental
problems with callback spawning, which could also lead to non-determinism.

\section{Research Question \& Goal}%
\label{sec:goal}


This thesis aims to construct a formal model which could later be adopted by
future revisions of Reactive Async. Constructing a model similar to that
of LVish but in an object-oriented setting, the final goal
will be to mathematically prove a form of determinism for the system.

Doing this will hopefully give us an answer to the research question:

\begin{quotation}
  How can we enforce a deterministic concurrent model similar to LVish in an
  object-oriented setting?
\end{quotation}

\section{Methodology}%
\label{sec:methodology}

We use the theory of programming language semantics and type systems to build a
simple object-oriented language. The type system incorporates theory that
relates to the object capability model from computer security, also utilized in
previous work by \textcite{conf/oopsla/HallerL16}.  After defining the property
of a well-typed program state, we prove that this is preserved during execution.
Furthermore, we prove that an execution of a well-typed program will not get
stuck unless there is a null-pointer exception. Finally, we prove a form of
determinism for the system.

\section{Contributions}%
\label{sec:contributions}

With this work, the following technical contributions are made:
\begin{itemize}
  \item Identification and exemplification of  problems with previous work on
    deterministic concurrency.
  \item Formalization of a core object-oriented language for deterministic
    concurrency.
  \item Design and formalization of an accompanying type system.
  \item A proof of soundness for the core language and type system.
  \item A proof of quasi-determinism, a form of determinism, for our
    formalized system.
\end{itemize}

\section{Sustainability \& Ethical Aspects}%
\label{sec:sustainability_&_ethical_aspects}

% ethics:
% hard to overlook
% can not anticipate all uses of this technology

% sustainability: 
% similarly somewhat hard to overlook the consequences due to theoretical nature
% energy use of data processing is a problem
% technology like deterministic-by-design systems might introduce overhead
% might also make computations more efficient if we can create incentive to
% parallelize computations more, might make resource usage more efficient
% hard to overlook what is more beneficial
% does the increased efficiency and safety justify the increased overhead? <-- main question
%
% should give some ending discussion of this main question in the discussion and
% conclusions chapter
The theoretical nature of this work makes the ethical consequences hard to
overlook since we cannot 
While this work migh have consequences with regards to sustainability, these are
hard to overlook due to the theoretical nature of the work. The same applies to
ethical aspects. Therefore the discussion of these are not really applicable.

\section{Report Structure}%
\label{sec:report_structure}

In Chapter~\ref{cha:background} some technical background is described. This
includes some mathematical definitions, an introduction to programming language
formalization and an informal description of the object capability
model. Chapter~\ref{cha:related_work} describes some selected related work, upon
which our model will build. In Chapter~\ref{cha:challenges} we describe and
exemplify some problems with some existing deterministic-by-design concurrent
systems. In Chapter~\ref{cha:core_language} we introduce our core language and
formalization. Chapter~\ref{cha:properties_of_racl} describes the theorems and
proofs of soundness and quasi-determinism. Finally, in
Chapter~\ref{cha:discussion_and_conclusion} we discuss extensions and
implementation of our formal system, as well as conclude the report.



