\chapter{Discussion \& Conclusion}
\label{cha:discussion_and_conclusion}

In this chapter, RACL, the formal system of this work is discussed from two
angles: extensions and implementation. Finally the report is summarized with
conclusions.
% EXTENSIONS:
% TODO discuss quiescence: allows us to use the result and freeze values
% TODO discuss allowing gets
% TODO 

% Could this be in conclusions?
% GENERAL:
% TODO great care has to be taken when designing and proving things about
% deterministic-by-design systems

% IMPLEMENTATION
% Threshold set is not a viable approach and only an abstraction. In reality you
% would have to do something similar to the implementation of LVish: Atomic
% lattices. Have some
% function that generates callbacks: I.e. for the new value, spawn some new
% callbackthreads

\section{Possible Extensions}%
\label{sec:extensions}

Currently, RACL does not have any way to actually use the result of a
computation. That is, there is no way to access the final cell values. The
freeze operation of LVish~\parencite{kuper2014freeze} is flawed and allows us to
write non-deterministic programs.  However, as hinted in the end of
Section~\ref{sec:a_problem_of_lvish} there should be a way to freeze values and
access them without breaking determinism.  This uses a form of of quiescence,
the concept introduced by~\textcite{kuper2014freeze}. The difference is that
this new form of freezing needs to be done globally, and at a time where changes
to cell values are no longer going to take place. Quiescence allows us to do
this. For example, if no threads are running or waiting to spawn,
we can be sure that the cell values will not change. Therefore, with this
definition of quiescence, introducing a program statement which blocks until
quiescence and then freezes all cells, should allow us to access the result
without risking non-determinism. In order to ensure this does not cause
deadlocks, this \emph{on-quiescence-freeze} operation should only be allowed in
the sole main (non-$\ocap$) thread of RACL.

As mentioned in Section~\ref{sec:lvars}, LVars has an additional \emph{get}
operation, not modeled in RACL. Adopting the semantics of LVars, it should be
possible to extend RACL with this operation aswell.


\section{Implementation}%
\label{sec:implementation}

In order to implement RACL effectively, some changes have to be made in the way
callbacks are registered and spawned. This is mainly due to that the dependency
set sematics of our formal system are hard to implement effectively, since it
requires scanning the sets for threshold values that have been passed. The time
required for this operation is linear in the combined size of dependency sets.
The LVish implementation solved this by optimizing their library for so called
atomic lattices, i.e., lattices where all values can be written as a join of so
called \emph{atoms}. An atom $a$ is an element of the lattice $\LatVals$ where
$l \sqsubseteq a \implies l \in \{\bot, a\}$. Instead of using the threshold set
semantics, the LVish implementation uses the concept of


% TODO discussion: bring up fact of running callbacks twice does not
% affect result

% Discuss the addition of quiescence in order to actually use the result of the
% computation. Also discuss the efficiency of our system. In order to make it
% usable we need to replace the threshold checks with some callback that spawns
% the required callbacks. This of course is also required to not depend on any
% shared mutable state.
% Discuss threshold reads: Could introduce a get stmt. Draw some
% conclusions of the problematic nature of deterministic concurrency and that
% great care has to be taken when trying to prove determinism for so called
% "deterministic-by-design" systems.
% SHould also



