\chapter{Background} \label{cha:background}

This chapter is a brief introduction to language and type system theory. In
section~\ref{sec:language_syntax} some basics of language syntax will be
explained. Section~\ref{sec:language_semantics} gives a brief introduction to
programming language semantics. Finally section~\ref{sec:type_systems} explains
some basics of programming language type systems.

As a basis the well known While language will be used as an example language.

% TODO add a section about basic math, like lattices join operations, partial
% maps

\section{Language Syntax} \label{sec:language_syntax}

% Describe the foundations of syntaxes for languages: BNF, ANF
A language syntax is a formal way to describe the structure of programs written
in a programming language. It gives us a basis on which to build the language
semantics and type systems as will be clear later. In this section the
Backus-Naur-form (BNF) will be introduced. 

\subsection{The Backus-Naur-form} \label{sub:the_backus_naur_form} 

Backus-Naur-form (BNF) is a very common way to describe the syntax of
programming languages. BNF describes a syntax using rules of the form
\begin{equation*}
  s ::= \text{<expression>}.
\end{equation*}
The the left side symbol $s$ is refered to as a non-terminal. <expression> could
also be a list of the
possible forms of $s$, separated by $|$, i.e. 
\begin{equation*}
  s ::= \text{<expression1>} \: | \dots | \: \text{<expressionN>}
\end{equation*}
The expressions can themselves contain non-terminals and terminals.
Terminals are symbols which does not occur on the left side of any rule.

The While language can be written in BNF as described
in~\parencite{nielson2007semantics} For reference we give a similar description
here with the addition of a very simple type system.

Furthermore we let $\WhVar$ be the set of all variable names and $\WhVal$ the
set of all values which for the While language will be the integers $\integers$,
and the boolean values $\WhTrue$ and $\WhFalse$. 
\begin{equation*}
  \WhVal = \integers \cup \left\{ \WhTrue, \WhFalse \right\}
\end{equation*}
Note that in~\parencite{nielson2007semantics} 
the conversion between the syntactical (numerals\slash boolean literals) and semantic
(integers\slash boolean values) versions of values are explicit whereas here 
this conversion is implicit.

\begin{figure}[h]
  \centering
  $\begin{array}{lll@{\hspace{4mm}}l}
    c &::= &  & \mbox{Program code} \\
    &  & \varepsilon & \mbox{Empty code} \\
    &| & s; c' & \mbox{Statement concatenation} \\
    s &::= & & \mbox{Program statement} \\
    &  & \WhDecl{x}{\tau} & \mbox{Variable declaration} \\
    &| & \WhAssign{x}{e} & \mbox{Assignment} \\
    &| & \WhSkip & \mbox{Skip} \\
    &| & \WhIf{e}{c_1}{c_2} & \mbox{If branch} \\
    &| & \WhWhile{e}{c} & \mbox{While loop} \\
    &&&\\
    e & ::= & & \mbox{Expressions} \\
    & & x & \mbox{Variable} \\
    &| & v & \mbox{Value literal} \\
    &| & \WhAdd{e_1}{e_2} & \mbox{Addition} \\
    &| & \WhTimes{e_1}{e_2} & \mbox{Multiplication} \\
    &| & \WhMinus{e_1}{e_2} & \mbox{Subtraction} \\
    &| & \WhEq{e_1}{e_2} & \mbox{Equality comparison} \\
    &| & \WhLeq{e_1}{e_2} & \mbox{$\leq$ comparison} \\
    &| & \WhLnot{e} & \mbox{Logical not} \\
    &| & \WhLand{e_1}{e_2} & \mbox{Logical and} \\
    &&&\\
    \tau & ::= & & \mbox{Types} \\
    & & \WhBool & \mbox{Boolean type} \\
    &| & \WhInt & \mbox{Integer type} \\
    &&&\\
    v & ::= & & \mbox{Values} \\
    &  & n & \mbox{Integer} \\
    &| & \WhTrue & \mbox{Boolean true} \\
    &| & \WhFalse & \mbox{Boolean false} \\
  \end{array}$
  \caption{Grammar of While}
  \label{fig:while_grammar}
\end{figure}

\section{Small-step Operational Semantics} \label{sec:language_semantics}

% Describe small step operational semantics and give example with while lang
In order to prove properties of a program you must be able to formally describe
the "meaning" of the program, i.e. to describe how programs statements modify
state and what execution steps can be taken. A common approach to this is
small-step operational semantics, also called structural operational semantics
(SOS). Other approaches includes big-step operational semantics or natural
semantics, and denotational semantics. Since SOS models concurrency well this is
the only one described here.

Small-step operational semantics defines rules which can be used to derive
single execution steps (or transitions) between program states. We exemplify
this with the While language defined in the above section. In order to define
rules for state transitions a state must be defined. Therefore we make the
following definition for the While language.

\begin{definition}
  A \emph{state} $S$ for the While language is a value of the form
  \begin{equation*}
    \WhState{V, c}  
  \end{equation*}
  where $c$ is a statement and $V$ is a partial map
  \begin{equation*}
    V: \WhVar \rightharpoonup \WhVal
  \end{equation*}
\end{definition}

We can now define rules for state transitions (see Figure~\ref{fig:while_sos}).
All rules are of the form
\infrule[Rule name]
{\text{precondition}}
{S \rightarrow S'}
Which basically says "if precondition holds then we can step from $S$
to $S'$".  If there are no preconditions we just write
\infax[Rule name]
{S \rightarrow S'}

\begin{figure}[h]
  \centering
  \infax[WhE-Decl1]
  {\WhState{V, \WhDecl{x}{\WhInt};c} \: \rightarrow \: \WhState{V[ x \mapsto 0],
  c}}
  
  \RuleSpace

  \infax[WhE-Decl2]
  {\WhState{V, \WhDecl{x}{\WhBool};c} \: \rightarrow \: \WhState{V[ x \mapsto
  \WhFalse], c}}
  
  \RuleSpace

  \infax[WhE-Assign]
  {\WhState{V, \WhAssign{x}{e};c} \: \rightarrow \: \WhState{V[ x \mapsto
  \WhEval{V}(e)], c}}

  \RuleSpace

  \infax[WhE-Skip]
  {\WhState{V, \WhSkip; c} \: \rightarrow \: \WhState{V, c}}

  \RuleSpace

  \infrule[WhE-IfTrue]
  {\WhEval{V}(e) = \WhTrue}
  {\WhState{V, \WhIf{e}{c_1}{c_2};c} \: \rightarrow \: \WhState{V, c_1;c}}

  \RuleSpace 

  \infrule[WhE-IfFalse]
  {\WhEval{V}(e) = \WhTrue}
  {\WhState{V, \WhIf{e}{c_1}{c_2}} \: \rightarrow \: \WhState{V, c_2;c}}
  
  \RuleSpace

  \infax[WhE-While]
  {\WhState{V, \WhWhile{e}{c'};c} \: \rightarrow \: \WhState{V,
  \WhIf{e}{(\WhConc{c'}{\WhWhile{e}{c'}})}{\WhSkip};c}}

  \caption{Small-step operational semantics for While}
  \label{fig:while_sos}
\end{figure}

Most of the rules are very intuitive. For example, rules {\sc WhE-Decl1} and {\sc
WhE-Decl2} extends the state map $V$ with $x$ and a default value corresponding
to the declared type. Rule {\sc WhE-Assign} evaluates the expression $e$ and
maps $x$ to the result. Rules {\sc WhE-IfTrue} and {\sc WhE-IfFalse} evaluates
its expression $e$ and if the result is $\WhTrue$ or $\WhFalse$ they prepend the
code of the corresponding branch to the rest of the program. We can also see
that {\sc WhE-While} is just an expansion of a while loop into an if statement.
Finally we note that we can not step from $\WhState{V, \varepsilon}$ which means
that this is a halting state.

The SOS rules of While heavily relies on the expression evaluation function
$\WhEval{\cdot}(\cdot)$. This is a function which takes a state map $V$ and an
expression $e$ and returns a value in $\WhVal$. We define this recursively as follows
\begin{equation*}
  \begin{array}{lll}
    \WhEval{V}(v) &=& v \\
    \WhEval{V}(x) &=& V(x) \\
    \WhEval{V}(e_1 + e_2) &=& \WhEval{V}(e_1) + \WhEval{V}(e_2) \\
    \WhEval{V}(e_1 * e_2) &=& \WhEval{V}(e_1) * \WhEval{V}(e_2) \\
    \WhEval{V}(e_1 - e_2) &=& \WhEval{V}(e_1) - \WhEval{V}(e_2) \\
    \WhEval{V}(e_1 = e_2) &=& \WhEval{V}(e_1) = \WhEval{V}(e_2) \\
    \WhEval{V}(e_1 \leq e_2) &=& \WhEval{V}(e_1) \leq \WhEval{V}(e_2) \\
    \WhEval{V}(e_1 \land e_2) &=& \WhEval{V}(e_1) \land \WhEval{V}(e_2) \\
    \WhEval{V}(\lnot e_1) &=& \lnot \WhEval{V}(e_1) \\
  \end{array}
\end{equation*}
Here we implicitly rely on that the operations $+, -, *, =, \leq$ are only
defined for integer values, and that $\lnot, \land$ are only defined for boolean
values.  If we encounter a state map $V$ and an expression $e$ where the
corresponding integer or boolean operation above is undefined, the value for
$\WhEval{V}(e)$ is undefined. Since the definition of $\WhEval{\cdot}(\cdot)$ is
recursive, the occurrence of an undefined value should also propagate upwards.
For example, if $\WhEval{V}(e_1)$ is undefined then $\WhEval{V}(e_1 + e_2)$ is undefined
aswell. This is implicit in our definition.

The evaluation function $\WhEval{\cdot}(\cdot)$ together with the derivation
rules in Figure~\ref{fig:while_sos} gives us a complete description of what
steps are allowed. It is implicit in the description that if the evaluation
function is undefined at some point in the derivation of a step, execution
cannot progress and we get stuck.

\section{Type Systems} \label{sec:type_systems}

A type system is a mathematical construct that consists of elements called types
and a set of rules that assign types to parts of a programming language, e.g.,
statements, variables and expressions. Type systems are most commonly used to
prevent programming errors such as feeding a data structure to a function for
which it was not made, and this can be enforced both using static checking at
compile time or dynamic checking at runtime. Type systems are found in many
modern programming languages such as Java, Scala, Haskell, Python and C++.

The focus here will be on static type systems. We will explain the basics using
our previous example of the While language. Then some uses and extensions will be
explained.

\subsection{A Type System for While}
\label{sub:a_type_system_for_while}

For the While language we have the following types:
\begin{equation*}
  \WhInt \andalso \WhBool \andalso \WhVoid
\end{equation*}
We call the set of all types 
\begin{equation*}
  \WhTpe = \left\{ \WhInt, \WhBool, \WhVoid \right\}.
\end{equation*}
Our typing rules will define a relation of the form
\begin{equation} \label{eq:tpe_sys1}
  \Gamma \vdash r : \tau.
\end{equation}
Here $\Gamma$ is a \emph{typing environment}, i.e. a partial map
\begin{equation*}
  \Gamma: \WhVar \rightharpoonup \WhTpe,
\end{equation*}
$r$ is either code or an expression and $\tau \in \WhTpe$.
Equation \eqref{eq:tpe_sys1} basically reads "$r$ is typed as $\tau$ under the
typing environment $\Gamma$." A program $c$ is typeable if
\begin{equation*}
  \emptyset \vdash c : \WhVoid
\end{equation*}
where $\emptyset$ is the empty typing environment, i.e. $\emptyset(x)$ is
undefined for all $x \in \WhVar$.

\begin{notation}
  Sometimes you would like to remap a key of, or extend a partial map $M$. One notation
  for this commonly used is 
  \begin{equation*}
    M[k \mapsto v],
  \end{equation*}
  which means that $M(l) = M[k \mapsto v](l)$ for all $l \neq k$ and
  $M(k) = v$.
  For typing environments we will also use the notation
  \begin{equation*}
    \Gamma, x: \tau
  \end{equation*}
  which is equivalent to $\Gamma[x \mapsto \tau]$.
\end{notation}

\begin{figure}[h]
  \infax[WhT-Empty]
  {\Gamma \vdash \varepsilon : \WhVoid}

  \RuleSpace

  \infrule[WhT-Decl]
  {\Gamma(x) \text{ undefined} \andalso \Gamma, x: \tau \vdash c : \WhVoid}
  {\Gamma \vdash \WhDecl{x}{\tau}; c : \WhVoid}

  \RuleSpace 

  \infrule[WhT-Assign]
  {(x: \tau) \in \Gamma \andalso \Gamma \vdash e: \tau \andalso \Gamma \vdash c
  : \WhVoid}
  {\Gamma \vdash \WhAssign{x}{e}; c : \WhVoid}

  \RuleSpace

  \infrule[WhT-Skip]
  {\Gamma \vdash c : \WhVoid}
  {\Gamma \vdash \WhSkip; c : \WhVoid}

  \RuleSpace

  \infrule[WhT-If]
  {\Gamma \vdash e : \WhBool \andalso \Gamma \vdash c_1: \WhVoid \\
  \Gamma \vdash c_2 : \WhVoid \andalso \Gamma \vdash c: \WhVoid}
  {\Gamma \vdash \WhIf{e}{c_1}{c_2}; c : \WhVoid}

  \RuleSpace

  \infrule[WhT-While]
  {\Gamma \vdash e: \WhBool \andalso \Gamma \vdash c' : \WhVoid \andalso \Gamma
  \vdash c : \WhVoid}
  {\Gamma \vdash \WhWhile{e}{c'}; c : \WhVoid}

  \caption{While program code typing rules.}
  \label{fig:while_code_tpe}
\end{figure}

Typing rules for program code are defined in Figure~\ref{fig:while_code_tpe}.
Generally While program code can only be typed as $\WhVoid$. Intuitively this is
because the execution of program code does not have a resulting value. Instead
it can only modify the state map $V$. The rules for typing program code should
not be hard to understand. For example, {\sc WhT-Assign} states that for code that
starts with an assignment the expression in the assignment must be of the same
type as the variable. {\sc WhT-If} requires that the expression is typeable as
$\WhBool$ and that both branches should be typeable as $\WhVoid$.

\begin{figure}[h]
  \begin{multicols}{3}
  \infax[WhT-Num]
  {\Gamma \vdash n : \WhInt}

  \infax[WhT-True]
  {\Gamma \vdash \WhTrue: \WhBool}

  \infax[WhT-False]
  {\Gamma \vdash \WhFalse: \WhBool}
  \end{multicols}

  \RuleSpace

  \infrule[WhT-Var]
  {(x: \tau) \in \Gamma}
  {\Gamma \vdash x: \tau}

  \RuleSpace

  \infrule[WhT-Add]
  {\Gamma \vdash e_1: \WhInt \andalso \Gamma \vdash e_2: \WhInt}
  {\Gamma \vdash e_1 + e_2: \WhInt}

  \RuleSpace

  \infrule[WhT-Times]
  {\Gamma \vdash e_1: \WhInt \andalso \Gamma \vdash e_2: \WhInt}
  {\Gamma \vdash e_1 * e_2: \WhInt}

  \RuleSpace

  \infrule[WhT-Minus]
  {\Gamma \vdash e_1: \WhInt \andalso \Gamma \vdash e_2: \WhInt}
  {\Gamma \vdash e_1 - e_2: \WhInt}

  \RuleSpace 

  \infrule[WhT-Eq]
  {\Gamma \vdash e_1: \WhInt \andalso \Gamma \vdash e_2: \WhInt}
  {\Gamma \vdash e_1 = e_2: \WhBool}

  \RuleSpace 

  \infrule[WhT-Leq]
  {\Gamma \vdash e_1: \WhInt \andalso \Gamma \vdash e_2: \WhInt}
  {\Gamma \vdash e_1 \leq e_2: \WhBool}

  \RuleSpace

  \infrule[WhT-Not]
  {\Gamma \vdash e : \WhBool}
  {\Gamma \vdash \lnot e: \WhBool}

  \RuleSpace 

  \infrule[WhT-And]
  {\Gamma \vdash e_1: \WhBool \andalso \Gamma \vdash e_2: \WhBool}
  {\Gamma \vdash e_1 \land e_2: \WhBool}

  \caption{While expression typing rules.}
  \label{fig:while_expr_tpe}
\end{figure}

Finally the rules for typing expressions are found in
Figure~\ref{fig:while_expr_tpe}. The possible types for an expression are
$\WhInt$ and $\WhBool$. The rules themselves should not be difficult to
understand.


\subsection{Uses \& Extensions}
\label{sub:uses_and_extensions}

So what are type systems used for? As mentioned earlier, commonly they are put
in place to prevent errors such as uncompatible data structures being fed as arguments
to a function which cannot handle such properly. For example, in Java you cannot feed a
List to a method which is denoted to take an Integer as an argument. This will
result in a compiler error.

\subsection{Preservation \& Progress}
\label{sub:preservation_&_progress}

A formal type system can furthermore be used to prove properties like
\emph{preservation} and \emph{progress} for programs which are properly type
checked. These are important properties since they can beforehand ensure that
programs terminate properly, or at least that, e.g., if it terminates erroneously it
must have been the result of a null-pointer exception. Progress and preservation
together is often refered to as \emph{soundness} of a type system and to prove this
is a standard approach. For a more in depth explanation
see~\parencite{pierce2002types}.

As an example we can state preservation and progress properties of While as follows. Let
$\Gamma(V)$ be defined as 
\[
  \Gamma(V)(x) = \begin{cases}
    \WhInt & \text{ if } V(x) \in \integers \\
    \WhBool & \text{ if } V(x) \in \left\{\WhTrue, \WhFalse \right\} \\
    \text{undefined} & \text{ otherwise }
  \end{cases}
\]
\begin{proposition}{(Preservation of While)} 
  Let
  \begin{equation*}
    \WhState{V, c} \: \rightarrow \: \WhState{V', c'} \andalso \Gamma(V) \vdash
    c: \WhVoid.
  \end{equation*}
  Then 
  \begin{equation}
    \Gamma(V') \vdash c': \WhVoid
  \end{equation}
\end{proposition}
\begin{proposition}{(Progress of While)}
  Let $\WhState{V, c}$ be a state and let
  \begin{equation*}
    \Gamma(V) \vdash c: \WhVoid.
  \end{equation*}
  Then either $c = \varepsilon$ or there is a state $\WhState{V', c'}$ such that
  \begin{equation*}
    \WhState{V, c} \: \rightarrow \: \WhState{V', c'}.
  \end{equation*}
\end{proposition}


\subsection{Extensions}
\label{sub:extensions}

The example type system for While is of course very simple. This is mostly due
to the simplicity of the language itself, more complicated languages have more
complicated type systems and a type system is oftenmost designed in together 
with the language itself. 

One common construct in type systems is \emph{subtyping}. This introduces a a
(semi)-lattice with based on a partial order relation denoted $\stof$ between
types and it oftenmost is used to say that "if $\sigma \stof \tau$ then values
of type $\sigma$ can be used in the same way as values of type $\tau$". This is
the case for Java where a class $C$ can extend a class $D$. This for simply
stated means that the fields and methods of $D$ are also availible in $C$. We
will see an example of how subtyping can be used in
chapter~\ref{cha:core_language}. 

In chapter~\ref{cha:core_language} the typing relation will also include an
effect $a$. In short this means that the typing rules are more or less strict
depending on the value of $a$.

